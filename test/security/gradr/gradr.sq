-- See Model.sq for definitions

{- Database API -}
-- | TODO: Fix me to add security
-- loadValue :: World ->  -> a
-- | TODO: Fix me, does this function even make sense?
-- storeValue :: World -> a -> Key a
-- Current environment (TODO: needed?)

-- predicate sessionUser :: World -> Maybe UserId
-- getSessionUser ::
--   w: World ->
--   Tagged {Maybe UserId | _v == sessionUser w} <{_0 == sessionUser w}>

-- type TagPred = World -> User -> Bool

-- renderMs :: <pp :: TagPred> . x:(List (Tagged a <pp>)) -> Tagged {List a |}
defaultPage :: String
-- defaultPage = render "Page could not be found or you are not authorized to see it"

-- display
--   :: <pp :: User -> Bool>
--   .  w:      World
--   -> viewer: Tagged {User | pp _v} <pp>
--   -> x:      Tagged Page <pp>
--   ->         World

-- public homepage
homePageString :: Tagged String <{True}>

homePage :: World -> World
homePage = \w .
  let u = getSessionUser w in
  print w u homePageString

-- test if user is in class
-- testIfStdInClass :: w: World -> u:User -> c: Class -> Tagged Bool <{_0== u}>
-- testIfStdInClass = \w . \u . \c .
--   elem u (getClassStudents w c)

-- isUser :: u: User -> u2:Tagged User <{_0 }>

-- get list of classes the user is a student in
getClassesStdByUser
  :: w: World
  -> u: User
  -> Tagged (List {Class | u in (classStudents w)[[_v]]}) <{_0 == u}>
getClassesStdByUser = \w . \u . filterM (isStudentInClass w u) (getClasses w)

-- get list of classes the user is an instructor/teacher for
getClassesInsByUser
  :: w: World
  -> u: User
  -> Tagged (List {Class | u in (classTeachers w)[[_v]] || u == (classInstructor w)[[_v]]}) <{True}>
getClassesInsByUser = \w . \u . filterM (teachesClass w u) (getClasses w)

getProfileClassInfo :: World -> u:User -> Tagged String <{_0 == u}>
getProfileClassInfo = \w . \u .
  let teachingClasses = getClassesInsByUser w u in
  let takingClasses = getClassesStdByUser w u in
    liftM2 strcat
      (liftM show teachingClasses)
      (liftM show takingClasses)

defaultProfileClassInfo :: Tagged String <{True}>

-- defaultProfileClassInfo :: Tagged String <{True}> -- "not authorized"

-- View Student user profile
profileView :: World -> World
profileView = \w .
  let u = getSessionUser w in
  let content = bind u (\user . getProfileClassInfo w user) in
  print w u content

predicate arbUser :: World -> User
getArbitraryUser :: w:World -> Tagged {User | _v == arbUser w} <{True}>

-- qualifier {(_0 == arbUser w)}

unauthProfileView :: World -> World
unauthProfileView = \w .
  let u = getSessionUser w in
  let content = bind u (\user . getProfileClassInfo w user) in
  print w ( (getArbitraryUser w)) content

-- View class: Instructor view
-- classInstructor :: World -> World
-- classInstructor = \w .
--   let u = getSessionUser w in

-- For an assignment, see all the scores for that assignment
scoresForAssignmentView :: World -> Assignment -> World
scoresForAssignmentView = \w . \assn .
  let u = getSessionUser w in
  let students = getStudentsWhoDidAssignment w assn in
  let scores = mapM (\student . getScore w student assn) students in
  print w u (liftM show scores)

-- For a student, see all of their scores
scoresForStudentView :: World -> User -> World
scoresForStudentView = \w . \student .
  let u = getSessionUser w in
  let assns = getAssignmentsForStudent w student in
  let scores = mapM (\assn . getScore w student assn) assns in
  print w u (liftM show scores)

--getTopScoreForAssignmentView :: World -> Assignment -> World
--getTopScoreForAssignmentView = \w . \assn .
--  let u = getSessionUser w in
--  let students = getStudentsWhoDidAssignment w assn in
--  let scores = mapM (\student . getScore w student assn) students in
--  let topScore = bind scores (\s . bind defaultScore (\def . foldM (\score1 . \score2 . ifM (return compareScores) (return score1) (return score2)) def s)) in
--  print w u (liftM show topScore)
