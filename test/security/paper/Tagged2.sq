{- Tagged2 -}

-- | Type of propositions used in proofs (Unit in disguise)
data Prop where
  PTrue :: Prop
  
-- | Untypable term  
fail :: {Prop | False} -> a

-- | State two propositions and have both of their types available 
-- (j is a workaround for our type system that throws away environment variables that are not mentioned)
predicate j :: Prop -> Prop -> Prop -> Bool
join :: x: Prop -> y: Prop -> {Prop | j x y _v}

data User

-- | Context
ctx :: User

-- | Two values in two different executions
data Tagged2 a <visibleTo :: User -> Bool>! where
  Tagged2 :: l: a -> r: a -> proof: ({Prop | visibleTo ctx} -> {Prop | l == r}) -> Tagged2 a <visibleTo>
  
measure left :: Tagged2 a -> a where
  Tagged2 l r proof -> l
  
measure right :: Tagged2 a -> a where
  Tagged2 l r proof -> r

return :: <p :: User -> Bool> . x: a -> Tagged2 a <p>
return = \x . Tagged2 x x (\_ . PTrue) -- x == x always holds

predicate f :: a -> Tagged2 b -- TODO: make one automatically for each function

bind :: <p :: User -> Bool> .
  x: Tagged2 a <p> -> (u: a -> {Tagged2 b <p> | _v == f u}) -> {Tagged2 b <p> | (left _v == left (f (left x))) && (right _v == right (f (right x)))}
bind = \x . \g . 
  match x with
    Tagged2 xl xr xp -> 
      match g xl with
        Tagged2 yl _ yp ->
          match g xr with 
            Tagged2 _ yr _ -> Tagged2 yl yr 
                                (\z . join (xp z) (yp z)) -- z holds the fact that p ctx holds, from there xp z gives us xl == xr, so f xl == f xr
  
bindBool :: <p :: User -> Bool> . <c :: Bool> .
  x: Tagged2 {Bool | _v ==> c} <{p _0 && c}> -> 
  (u: {Bool | _v ==> c} -> {Tagged2 b <p> | _v == f u}) -> 
    {Tagged2 b <p> | (left _v == left (f (left x))) && (right _v == right (f (right x)))}
bindBool = \x . \g . 
  match x with
    Tagged2 xl xr xp -> 
      match g xl with
        Tagged2 yl _ yp ->
          match g xr with 
            Tagged2 _ yr _ -> Tagged2 yl yr 
                                (\z . if xl || xr then join (xp z) (yp z) else yp z) -- if xl || xr, then c must hold, so we can invoke xp; otherwise xl == xr == false

{- Output -}
      
data World  

print :: <p :: User -> Bool> . w: World -> viewer: Tagged2 {User | p _v} <p> -> x: Tagged2 a <p> -> World
print = \w . \viewer . \x .
  match viewer with
    Tagged2 vl vr vp ->
      if vl != ctx && vr != ctx
        then w
        else 
          if vl != vr
            then fail (vp PTrue) -- p ctx holds, since p vl and p vr and (vl == ctx || vr == ctx), so we can call vp; vp proves vl == vr, a contradiction with the path condition
            else match x with
                  Tagged2 xl xr xp ->
                    if xl != xr 
                      then fail (xp PTrue) -- p ctx holds as before, so we can call xp; xp proves xl == xr, a contradiciton with the path condion
                      else w
