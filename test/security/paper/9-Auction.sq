data User

fmap :: (a -> b) -> Maybe a -> Maybe b
-- fmap = \f . \mb . 
  -- match mb with
    -- Nothing -> Nothing
    -- Just x -> Just (f x)

data Phase where
  Bidding :: Phase
  Done :: Phase
  
predicate sessionUser :: World -> User      
getSessionUser :: w: World -> Tagged {User | _v == sessionUser w} <{True}>  
  
predicate phase :: World -> Phase
getPhase :: w: World -> Tagged {Phase | _v == phase w} <{True}>

predicate hasBid :: World -> User -> Bool
getUserBid :: w: World -> u: User -> 
  Tagged { Maybe (Tagged Int <{ phase w == Done }>) | just _v == hasBid w u } <{ phase w == Done || hasBid w _0 }>  

maybe :: b -> (a -> b) -> Maybe a -> b
-- maybe = \v . \f . \mX .
  -- match mX with
    -- Nothing -> v
    -- Just x -> f x
    
zero :: {Int | _v == 0}

redact {zero, Nil, Nothing, fmap}
  
showBids :: World -> User -> User -> World
showBids = \w . \u . \who .
  -- let u = getSessionUser w in
  let getBid = getUserBid w who in                      
  let out = bind getBid (\mB . maybe (return emptyString) (\x . liftM show x) mB) in
  print w (return u) out

-- Repaired version:  
-- showBids = \w . \who .
  -- let u = getSessionUser w in
  -- let uBid = getUserBid w who in
  -- let getBid = do
                -- isDone <- bind (getPhase w) (\p . return (eq p Done))
                -- haveBid <- downgrade (bind u (\tu . liftM isJust (getUserBid w tu)))
                -- if isDone
                  -- then uBid
                  -- else if haveBid
                        -- then bind uBid (\b . return (fmap (\c . return 0) b))
                        -- else return Nothing
               -- in  
  -- let out = bind getBid (\mB . maybe (return emptyString) (\x . liftM show x) mB) in
  -- print w u out
  
  
  