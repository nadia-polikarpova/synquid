{-
  This example demonstrates sorting based on a sensitive criterion
-}

{- Datatypes -}

data PaperId

{- Sensitive data and policies -}
   
-- | Current session user
predicate sessionUser :: World -> User      
getSessionUser :: w: World -> Tagged {User | _v == sessionUser w} <{True}>

-- | PC chair (public)
predicate chair :: World -> User
getChair :: w: World -> Tagged {User | _v == chair w} <{True}>

getAllPaperIds :: w: World -> Tagged (List PaperId) <{True}>

-- | Paper title (public)
getPaperTitle :: w: World -> pid: PaperId -> Tagged String <{True}>

-- | Paper conflicts (public)
predicate paperConflicts :: World -> PaperId -> Set User
getPaperConflicts :: w: World -> pid: PaperId 
                        -> Tagged {List {User | _v in paperConflicts w pid} | elems _v == paperConflicts w pid} <{True}>

-- | Paper score
getPaperScore :: w: World -> pid: PaperId -> Tagged Int <{!(_0 in paperConflicts w pid)}>
defaultPaperScore :: Tagged Int <{True}>

{- Client code -}
  
-- | Sort papers by their score.
-- | Repair: inside cmpScore, check that u is not conflicted with pid1/2
sortPapersByScore :: w: World -> World
sortPapersByScore = \w .
  let u = getSessionUser w in
  let cmpScore = \pid1. \pid2.
    bind (getPaperScore w pid1) (\x1.
      bind (getPaperScore w pid2) (\x2. return (x1 <= x2))) in
  let sortedPids = bind (getAllPaperIds w) (\pids . sortByM cmpScore pids) in -- sorted paper IDs
  let titles = bind sortedPids (\pids . mapM (\pid . getPaperTitle w pid) pids) in
  let out = bind titles (\xs . foldM (\x . \y . return (strcat x y)) emptyString xs) in
  print w u out
  
-- | Repaired version:  
-- sortPapersByScore = \w .
  -- let u = getSessionUser w in
  -- let cmpScore = \pid1 . \pid2 .
        -- bind (ifM (bind u (\x7 . bind (getPaperConflicts w pid1) (\x6 . return (not (elem x7 x6))))) 
                  -- (getPaperScore w pid1)
                  -- defaultPaperScore) 
             -- (\x1 . bind (ifM (bind u (\x15 . bind (getPaperConflicts w pid2) (\x14 . return (not (elem x15 x14)))))
                              -- (getPaperScore w pid2)
                              -- defaultPaperScore) 
                         -- (\x2 . return (x1 <= x2))) in
  -- let sortedPids = bind (getAllPaperIds w) (\pids . sortByM cmpScore pids) in -- sorted paper IDs
  -- let titles = bind sortedPids (\pids . mapM (\pid . getPaperTitle w pid) pids) in
  -- let out = bind titles (\xs . foldM (\x . \y . return (strcat x y)) emptyString xs) in
  -- print w u out
  
