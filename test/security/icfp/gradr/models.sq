#define Instructor User
#define Teacher User
-- Users can be students or instructors

-- Students can be enrolled in classes
-- Instructors can manage classes
--  or can teach classes (there is an owner...?)

-- classes are owned by a professor and contain other teachers, students,
-- and assignments, with submissions and grades

{- Schema of the World:
CREATE TABLE "user"       ("id" INTEGER PRIMARY KEY,"ident" VARCHAR NOT NULL,"password" BLOB NOT NULL,"email_address" VARCHAR NOT NULL,"verified" BOOLEAN NOT NULL,"verify_key" VARCHAR NOT NULL,"reset_password_key" VARCHAR NOT NULL,CONSTRAINT "unique_user" UNIQUE ("email_address"));
CREATE TABLE "class"      ("id" INTEGER PRIMARY KEY,"name" VARCHAR NOT NULL,"term" VARCHAR NOT NULL,"instructor" INTEGER NOT NULL REFERENCES "user",CONSTRAINT "unique_class" UNIQUE ("name","term","instructor"));
CREATE TABLE "teacher"    ("id" INTEGER PRIMARY KEY,"name" INTEGER NOT NULL REFERENCES "user","class" INTEGER NOT NULL REFERENCES "class",CONSTRAINT "unique_teacher" UNIQUE ("name","class"));
CREATE TABLE "student"    ("id" INTEGER PRIMARY KEY,"name" INTEGER NOT NULL REFERENCES "user","class" INTEGER NOT NULL REFERENCES "class",CONSTRAINT "unique_student" UNIQUE ("name","class"));
CREATE TABLE "assignment" ("id" INTEGER PRIMARY KEY,"name" VARCHAR NOT NULL,"points" INTEGER NOT NULL,"class" INTEGER NOT NULL REFERENCES "class",CONSTRAINT "unique_assignment" UNIQUE ("name","class"));
CREATE TABLE "score"      ("id" INTEGER PRIMARY KEY,"student" INTEGER NOT NULL REFERENCES "user","assignment" INTEGER NOT NULL REFERENCES "assignment","points" INTEGER NOT NULL,CONSTRAINT "unique_score" UNIQUE ("student","assignment"));
CREATE TABLE "instructor" ("id" INTEGER PRIMARY KEY,"name" INTEGER NOT NULL REFERENCES "user");
CREATE TABLE "comment"    ("id" INTEGER PRIMARY KEY,"message" VARCHAR NOT NULL,"user_id" INTEGER NULL REFERENCES "user");
-}

data Maybe a where
  Nothing :: Maybe a
  Just :: a -> Maybe a

{- Rows in Tables -}
-- type Id = Int
-- type Ident = String
-- type Password = String
-- type EmailAddress = String
-- type Verified = Bool
-- data UserRow where
--   UserRow :: Id -> Ident -> Password ->
{- Tables in the "database" -}
-- predicate users :: World -> Set User
-- predicate class :: World -> 
-- predicate profiles :: World -> Map User String

{- User Data -}
-- predicate userEmail :: User -> String
--   userEmailAddress
-- predicate userPassword :: User -> String
-- -- getUserPassword :: World -> User -> 


-- type UserPassword = String
-- data UserPassword
-- data UserData where
--   UserData ::
--     who: Tagged User <{True}>
--     -> Tagged UserPassword <{_0 ==  content who}>
--     -> UserData

-- type UserId = Key UserData

data User
data Username
data Password
#if 0
type Instructor = User
type Teacher = User
#endif
defaultUser :: Tagged User <{True}>

predicate users :: World -> Set User
predicate usernames :: World -> Map User Username
predicate passwords :: World -> Map User Password
predicate sessionUser :: World -> User
-- getUsers :: w: World -> Tagged {List {User | _v in users w} | elems _v == users w} <{_0 == chair _0}>

getUsername :: World -> User -> Tagged Username <{True}>
-- getPassword -- Seems like a bad idea???
-- Why is pw tagged?
getSessionUser :: w: World -> Tagged {User | _v == sessionUser w} <{True}>

-- setPassword :: w: World -> u: User -> pw: Tagged String <{_0 == u}> ->
--   {World | users _v == users w &&
--            passwords _v == (passwords w) [[u := content pw]]}
addUser :: w: World -> u: User -> pw: String -> World

data Class
predicate classes :: World -> Set Class
type ClassName = String
type ClassTerm = String

predicate className :: World -> Class -> String
predicate classTerm :: World -> Class -> String
predicate classInstructor :: World -> Map Class Instructor
predicate classTeachers :: World -> Map Class (Set Teacher)
predicate classStudents :: World -> Map Class (Set User)
-- predicate classContains :: w: World -> c: Class -> u: User -> {Bool | ((classInstructor w)[[c]] == u) || (u in classTeachers w c )|| (u in classStudents w) }

getClassContains
  :: w: World
  -> c: Class
  -> u: User
  -> {Bool | _v ==  (   (u == (classInstructor w)[[c]])
                     || (u in (classTeachers   w)[[c]])
                     || (u in (classStudents   w)[[c]]))
     }
getClasses :: w:World -> {List (Class) | True} --elems _v == classes w}
getClassTeachers :: w: World -> c: Class -> Tagged {List Teacher | elems _v == (classTeachers w)[[c]]} <{True}>

getClassStudents
  :: w: World
  -> c: Class
  -> (Tagged (List {User | _v in (classStudents w)[[c]]})
       <{ _0 in (classTeachers w)[[c]]
       || _0 == (classInstructor w)[[c]]}>)

isStudentInClass
  :: w: World
  -> u: User
  -> c: Class
  -> (Tagged {Bool | _v == (u in (classStudents w)[[c]])}
       <{_0 == u || (_0 in (classTeachers w)[[c]]) || _0 == (classInstructor w)[[c]]}>)

teachesClass
  :: w: World
  -> u: User
  -> c: Class
  -> (Tagged {Bool | _v == (u in (classTeachers w)[[c]] || (u == (classInstructor w)[[c]]))}
       <{True}>)

getClassInstructor :: w: World -> c: Class -> Tagged {Instructor | _v == (classInstructor w)[[c]]} <{True}>

getClassName :: w: World -> u: Class -> Tagged String <{True}>

addClass
  :: w: World
  -> className: ClassName
  -> classTerm: ClassTerm
  -> instr: Instructor
  -> teachers: List {Teacher | _v != instr}
  -> World

data Assignment


-- {- Class Data -}
-- type ClassName = String
-- type ClassTerm = String
-- type ClassInstructor = User

-- data Class where
--   Class :: Tagged ClassName <{True}>
--     -> Tagged ClassTerm <{True}>
--     -> Tagged ClassInstructor <{True}>
--     -> Class
-- type ClassId = Key Class

{- Teachers -}
-- type TeacherName = Key User
-- type TeacherClass = Key Class
-- data Teacher where
--   Teacher :: TeacherName -> TeacherClass -> Teacher
-- type TeacherId = Key Teacher

-- {- Students -}
-- type StudentName = Key User
-- type StudentClass = Key Class
-- data Student where
--   Student :: StudentName -> StudentClass -> Student
-- type StudentId = Key Student

-- {- Assignments -}
-- type AssignmentName = String
-- type AssignmentPoints = Int
-- type AssignmentClass = ClassId
-- data Assignment where
--   Assignment :: AssignmentName -> AssignmentPoints -> AssignmentClass -> Assignment
-- type AssignmentId = Key Assignment

-- {- Scores -}
-- type ScoreStudent = StudentId
-- type ScoreAssignment = AssignmentId
-- type ScorePoints = Int
-- data Score where
--   Score :: ScoreStudent -> ScoreAssignment -> ScorePoints
-- type ScoreId = Key Score

-- {- Instructors -}
-- type InstructorName = UserId
-- data Instructor where
--   Instructor :: InstructorName -> Instructor

-- {- Comments -}
-- type CommentMessage = String
-- type CommentUserId = UserId
-- data Comment where
--   Comment :: CommentMessage -> CommentUserId -> Comment
-- type CommentId = Key Comment


-- {- Webpages -}
-- data Page
-- needsAuthOrNotFoundMessage :: Page


