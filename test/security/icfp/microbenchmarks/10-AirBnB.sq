{- 
  AirBnB bug: they scrape phone numbers from user messages, but forgot to do so in the preview.
  This example features a custom redaction function that makes a message text visible to the recipient,
  but not completely public.
  It also showcases expressive functional reasoning with higher-order functions,
  since correctness depends on the argument of filterM.
-}

{- Datatypes -}

data MessageId

{- Sensitive data and policies -}

getAllMessageIDs :: w: World -> [MessageId]

-- | AirBnB admin
predicate admin :: World -> User
getAdmin :: w: World -> Tagged {User | _v == admin w} <{True}>

-- | Message sender
predicate sender :: World -> Map MessageId User
getSender :: w: World -> m: MessageId -> Tagged {User | _v == (sender w)[[m]] && _v != (recipient w)[[m]]} <{True}>

-- | Message recipient
predicate recipient :: World -> Map MessageId User
getRecipient :: w: World -> m: MessageId -> Tagged {User | _v == (recipient w)[[m]] && _v != (sender w)[[m]]} <{True}>

-- | Message text (only visible to the admin and the sender)
getText :: w: World -> m: MessageId -> Tagged String <{_1 == admin _0 || _1 == (sender _0)[[m]]}>

-- | Scrape phone numbers from the message, making it visible to the recipient
scrapePhoneNumbers :: m: MessageId -> Tagged String <{_1 == admin _0 || _1 == (sender _0)[[m]]}>
                                   -> Tagged String <{_1 == admin _0 || _1 == (sender _0)[[m]] || _1 == (recipient _0)[[m]]}>

redact {scrapePhoneNumbers}

{- Client code -}
  
-- | View all client's messages.
-- | Repair: inside the first argument of mapM, check if client is admin (client cannot be sender as per refinement on getRecipient),
--           and otherwise scrape the message.
--           To determine that scraping the message is enough, we need to know that client is recipient for all messages in myMIDs,
--           which we infer from the type of filterM
viewInbox :: World -> User -> World
viewInbox = \w . \client .
  let isMyMessage = \m .
        do to <- getRecipient w m
           return (to == client) in
  let inbox = 
        do myMIDs <- filterM isMyMessage (getAllMessageIDs w) 
           messages <- mapM (\m . getText w m) myMIDs 
           return (unlines messages) in 
  print w (return client) inbox
  
