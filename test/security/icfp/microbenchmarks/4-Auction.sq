{- Auction: nontrivial redaction -}

{- Datatypes -}

data Phase where
  Bidding :: Phase
  Done :: Phase  
guard {Bidding, Done}

{- Sensitive data and policies -}   

getAllParticipants :: w: World -> [User]

-- | Auction phase (public)
predicate phase :: World -> Phase
getPhase :: w: World -> Tagged {Phase | _v == phase w} <{True}>

-- | User bid (fully visible to the user themselves and once the phase is done; partially visible to all users who have bid)
predicate hasBid :: World -> Map User Bool
getBid :: w: World -> u: User -> 
  Tagged { Maybe (Tagged Int <{ phase _0 == Done || _1 == u }>) | just _v == (hasBid w)[[u]] } 
    <{ phase _0 == Done || _1 == u || (hasBid _0)[[_1]]}>    
  
{- Client code -}  
  
-- | Show bids of all participants to `client`
-- | Repair: for getBid, check that phase is done or client is p,
--           otherwise check that client has bid, then apply `fmap (const 0)`
--           otherwise return Nothing
showBids :: World -> User -> World
showBids = \w . \client .
  let showParticipant = \p . 
    do mB <- getBid w p
       maybe (return emptyString) (\x . liftM show x) mB in
  let out = liftM unlines (mapM showParticipant (getAllParticipants w)) in
  print w (return client) out  
  
  