-- Conference management

data PaperId

data Phase where
  Submission :: Phase
  Review :: Phase
  Done :: Phase
  
guard {Submission, Review, Done}

data Status where
  NoDecision :: Status
  Accepted :: Status
  Rejected :: Status
  
guard {Submission, Review, Done}
redact {NoDecision}

data ReviewId

data ReviewScores where
  ReviewScoresEntry :: novelty: Int -> presentation: Int -> technical: Int -> confidence: Int -> ReviewScores
  
redact {ReviewScoresEntry}  

data Reviewer where
  ReviewerEntry :: idx: Int -> user: User -> Reviewer

measure ruser :: Reviewer -> User where
  ReviewerEntry i u -> u

anonymousReviewer :: Tagged Reviewer <{False}> -> Tagged Reviewer <{True}>
redact {anonymousReviewer}

data Review where
  ReviewEntry :: time: String -> contents: String -> scores: ReviewScores -> Review
  
redact {ReviewEntry}

data UserProfile where
  UserProfileRecord :: name: String -> affiliation: String -> acm_number: String -> email: String -> UserProfile
  
redact {UserProfileRecord}    

data Token

predicate users :: World -> Set User
getUsers :: w: World -> Tagged {List {User | _v in users w} | elems _v == users w} <{_1 == chair _0}>

predicate passwords :: World -> Map User String
getPassword :: w: World -> u: User -> Tagged {String | _v == (passwords w)[[u]]} <{_1 == u}>
setPassword :: w: World -> u: User -> pw: Tagged String <{_1 == u}> -> 
  {World | users _v == users w &&
           passwords _v == (passwords w) [[u := content pw]]}

addUser :: w: World -> u: User -> pw: String -> 
  {World | users _v == users w + [u] && 
           passwords _v == (passwords w) [[u := pw]]}

predicate userProfiles :: World -> Map User UserProfile
getUserProfile :: w: World -> u: User -> Tagged {UserProfile | _v == (userProfiles w)[[u]]} <{_1 == u || _1 == chair _0}>
setUserProfile :: w: World -> u: User -> Tagged UserProfile <{_1 == u || _1 == chair _0}> -> World

predicate sessionUser :: World -> User
getSessionUser :: w: World -> Tagged {User | _v == sessionUser w} <{True}>

predicate chair :: World -> User
getChair :: w: World -> Tagged {User | _v == chair w} <{True}>

predicate pc :: World -> Set User
getPC :: w: World -> Tagged {List {User | _v in pc w} | elems _v == pc w} <{True}>

predicate currentPhase :: World -> Phase
getCurrentPhase :: w: World -> Tagged {Phase | _v == currentPhase w} <{True}>

predicate paperConflicts :: World -> PaperId -> Set User
getPaperConflicts :: w: World -> pid: PaperId
   -> Tagged {List {User | _v in paperConflicts w pid} | elems _v == paperConflicts w pid} <{!(_1 in paperConflicts _0 pid)}>
setPaperConflicts ::  w: World -> pid: PaperId
   -> Tagged [User] <{!(_1 in paperConflicts _0 pid)}>
   -> {World | users _v == users w && passwords _v == passwords w}

getPaperTitle :: w: World -> pid: PaperId 
   -> Tagged String <{ !(_1 in paperConflicts _0 pid) }>
setPaperTitle :: w: World -> pid: PaperId
   -> Tagged String <{ !(_1 in paperConflicts _0 pid) }>
   -> {World | users _v == users w && passwords _v == passwords w}

predicate paperAuthors :: World -> Map PaperId (Set User)
getPaperAuthors :: w: World -> pid: PaperId 
   -> Tagged {List {User | (_v in (paperAuthors w)[[pid]]) && !(_v in paperConflicts w pid)} | elems _v == (paperAuthors w)[[pid]]} 
             <{_1 in (paperAuthors _0)[[pid]] }>
setPaperAuthors :: w: World ->  pid: PaperId 
   -> Tagged [User] <{_1 in (paperAuthors _0)[[pid]] }>
   -> {World | users _v == users w && passwords _v == passwords w}


predicate paperStatus :: World -> PaperId -> Status
getPaperStatus :: w: World -> pid: PaperId -> Tagged {Status | _v == paperStatus w pid} <{_1 == chair w || (currentPhase _0 == Done && _1 in (paperAuthors _0)[[pid]] )}>

getPaperSession :: w: World -> pid: PaperId -> Tagged String <{True}>

getAllPapers :: w: World -> [PaperId]

getFreshPaperId :: w: World -> PaperId
addPaper :: w: World -> newId: PaperId ->
  {World | users _v == users w &&  -- is it important that the new Id has been added to world? nahh...
           passwords _v == passwords w}

predicate paperReviewers :: World -> Map PaperId (Set User)
getPaperReviewers :: w: World -> pid: PaperId 
   -> Tagged {List {User | (_v in (paperReviewers w)[[pid]]) && !(_v in paperConflicts w pid)} | elems _v == (paperReviewers w)[[pid]]} 
             <{_1 in pc _0 && !(_1 in (paperConflicts _0 pid)) }>
setPaperReviewers :: w: World ->  pid: PaperId 
   -> Tagged [User] <{_1 in pc _0 && !(_1 in (paperConflicts _0 pid))}>
   -> {World | users _v == users w && passwords _v == passwords w}


predicate reviewAuthor :: World -> Map ReviewId Reviewer
getReviewAuthor :: w: World -> rid: ReviewId -> Tagged {Reviewer | _v == (reviewAuthor w)[[rid]]} <{_1 == chair _0}>
--   I want this:   <{_1 == chair _0 || _1 == ruser ((reviewAuthor _0)[[rid]])}>
setReviewAuthor :: w: World -> rid: ReviewId -> Tagged Reviewer <{_1 == chair _0}> -> World

predicate reviewPaper :: World -> Map ReviewId PaperId
getReviewPaper :: w: World -> rid: ReviewId -> Tagged {PaperId | _v == (reviewPaper w)[[rid]]} <{True}>
setReviewPaper :: w: World -> rid: ReviewId -> pid: Tagged PaperId <{True}> -> World

predicate reviews :: World -> Map ReviewId Review
getReview :: w: World -> rid: ReviewId -> Tagged {Review | _v == (reviews w)[[rid]]} <{_1 in (paperAuthors _0)[[ (reviewPaper _0)[[rid]] ]]}>
setReview :: w: World -> rid: ReviewId -> Tagged Review <{_1 in (paperAuthors _0)[[ (reviewPaper _0)[[rid]] ]]}> -> World

getAllReviews :: w: World -> [ReviewId]

getFreshReviewId :: w: World -> ReviewId

getPaperBidToken :: w: World -> pid: PaperId -> Tagged (Maybe Token) <{ {- !(_1 in (paperAuthors _0)[[pid]]) && -} (_1 in pc _0) && !(_1 in paperConflicts _0 pid) }>

{- Some Strings -}

s_delighted :: String
s_regret :: String

{- Extra combinators -}

foldl :: (a -> b -> a) -> a -> (List b) -> a
foldl1 :: f: (a -> a -> a) -> l: List a -> a

forM :: <ap :: World -> User -> Bool> .
   w: World -> l: Tagged (List a) <ap> -> f: (World -> (Tagged a <ap>) -> World) -> World
   
forM_ :: <ap :: World -> User -> Bool> .
   w: World -> l: Tagged (List (Tagged a <ap>)) <ap> -> f: (World -> (Tagged a <ap>) -> World) -> World

ifJust :: (Maybe a) -> (a -> b) -> b

-- TODO currently there has to be something here, otherwise nothing gets emitted

elemMaybe :: x: a -> xs: Maybe [a] -> Bool
elemMaybe = \x. \xs.
  match xs with
    Just l -> elem x l
    Nothing -> 0 == 0
