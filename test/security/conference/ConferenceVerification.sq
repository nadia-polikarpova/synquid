
-- and :: x: Bool -> y: Bool -> {Bool | _v == (x && y)}
foldl :: (a -> b -> a) -> a -> (List b) -> a
foldl1 :: f: (a -> a -> a) -> l: List a -> a

-- Strings

s_colon :: String
s_comma :: String
s_paperNo :: String
s_authors :: String
s_qmark :: String
toString :: a -> String

-- Conference management

data PaperId

data Phase where
  Submission :: Phase
  Review :: Phase
  Done :: Phase

data Status where
  NoDecision :: Status
  Accepted :: Status
  Rejected :: Status

predicate sessionUser :: World -> User
getSessionUser :: w: World -> Tagged {User | _v == sessionUser w} <{_0 == sessionUser w}>

predicate chair :: World -> User
getChair :: w: World -> Tagged {User | _v == chair w} <{True}>

predicate currentPhase :: World -> Phase
getCurrentPhase :: w: World -> Tagged {Phase | _v == currentPhase w} <{True}>

predicate paperConflicts :: World -> PaperId -> Set User
getPaperConflicts :: w: World -> pid: PaperId
                        -> Tagged {List {User | _v in paperConflicts w pid} | elems _v == paperConflicts w pid} <{!(_0 in paperConflicts w pid)}>

getPaperTitle :: w: World -> pid: PaperId -> Tagged String <{_0 in paperAuthors w pid || !(_0 in paperConflicts w pid)}>

predicate paperAuthors :: World -> PaperId -> Set User
getPaperAuthors :: w: World -> pid: PaperId -> Tagged {List {User | (_v in paperAuthors w pid) && !(_v in paperConflicts w pid)} | elems _v == paperAuthors w pid} <{_0 in paperAuthors w pid}>

predicate paperStatus :: World -> PaperId -> Status
getPaperStatus :: w: World -> pid: PaperId -> Tagged {Status | _v == paperStatus w pid} <{_0 == chair w || (currentPhase w == Done && _0 in paperAuthors w pid)}>

getPaperSession :: w: World -> pid: PaperId -> Tagged String <{True}>

getAllPapers :: w: World -> List PaperId

qualifier {x == w, x in y, !(x in y)}
qualifier {_v == (x in y), _v == !(x in y)}

-- Print paper status to all its authors
test1 :: World -> PaperId -> World
test1 = \w . \pid .
  let title = getPaperTitle w pid in
  let authors = getPaperAuthors w pid in
  let st = ifM (liftM2 eq (getCurrentPhase w) (return Done))
              (getPaperStatus w pid)
              (return NoDecision) in
	let out = foldl1 (liftM2 strcat) (Cons title (Cons (return s_colon) (Cons (liftM toString st) Nil))) in
  --                              ^ [title, return s_colon, liftM toString st]
  printAll w authors out

-- Print paper title to session user
{-
silly :: World -> PaperId -> World
silly = \w . \pid .
  let u = getSessionUser w in
  let title = getPaperTitle w pid in
  print w u (liftM toString title)

sillys :: World -> (List PaperId) -> World
sillys = \w . \pids .
  let u = getSessionUser w in
  foldl (\w. \pid. 
    let title = getPaperTitle w pid in
    print w u title) w pids
  match pids with
    Nil -> w
    Cons pid rest ->
  		let title = getPaperTitle w pid in
  		sillys (print w u (liftM toString title)) rest
-}
-- Print paper status to chair
test2 :: World -> PaperId -> World
test2 = \w . \pid .
  let ch = getChair w in
  let st = getPaperStatus w pid in
  print w ch (liftM2 strcat (return s_paperNo)
               (liftM2 strcat (return (toString pid))
                 (liftM2 strcat (return s_colon)
                   (liftM toString st))))

-- Print paper authors to session user
test3 :: World -> PaperId -> World
test3 = \w . \pid .
  let u = getSessionUser w in
  let authors = getPaperAuthors w pid in
  let authors' = ifM (liftM2 elem u authors) authors (return Nil) in
  let out = (liftM2 strcat (return s_paperNo)
              (liftM2 strcat (return (toString pid))
                (liftM2 strcat (return s_comma)
                  (liftM2 strcat (return s_authors)
                    (liftM toString authors'))))) in
  print w u out

-- Print paper status to session user
test4 :: World -> PaperId -> World
test4 = \w . \pid .
  let u = getSessionUser w in
  let st = ifM (liftM2 eq (getChair w) u)
                (getPaperStatus w pid)
                (ifM (andM (liftM2 eq (getCurrentPhase w) (return Done)) (liftM2 elem u (getPaperAuthors w pid)))
                  (getPaperStatus w pid)
                  (return NoDecision)) in
  print w u (liftM toString st)

-- Implicit flow: show status and session to session user
test5 :: World -> PaperId -> World
test5 = \w. \pid .
  let u = getSessionUser w in
  let conflicts = getPaperConflicts w pid in
  let title = ifM (liftM not (liftM2 elem u conflicts)) (getPaperTitle w pid) (return emptyString) in
  -- let st = getPaperStatus w pid in -- Leaky version
  let st = ifM (andM (liftM2 eq (getCurrentPhase w) (return Done)) (liftM2 elem u (getPaperAuthors w pid)))
                  (getPaperStatus w pid)
                  (return NoDecision) in
  let ses = bind st (\s . if s == Accepted
                            then getPaperSession w pid
                            else return emptyString) in
  let out = liftM2 strcat title (liftM2 strcat (liftM toString st) ses) in
  print w u out

-- Print paper title and list of conflicts to the session user
test6 :: World -> PaperId -> World
test6 = \w. \pid .
  let u = getSessionUser w in
  let conflicts = getPaperConflicts w pid in
  let noConflict = liftM not (liftM2 elem u conflicts) in
  let title = ifM noConflict (getPaperTitle w pid) (return emptyString) in
  let conflicts' = ifM noConflict conflicts (return Nil) in
  let out = liftM2 strcat title (liftM toString conflicts') in
  print w u out

selectFrom :: <sp :: User -> Bool> . World -> u: Tagged {User | sp _v} <sp> -> 
                 pids: List PaperId ->  List (Tagged String <{_0 == content u}>)
selectFrom = \w. \u. \pids .
  map (\pid.
      let conflicts = getPaperConflicts w pid in
      let title = ifM (liftM not (liftM2 elem u conflicts)) (getPaperTitle w pid) (return s_qmark) in
      let authors = getPaperAuthors w pid in
      let authors' = ifM (liftM2 elem u authors) authors (return Nil) in
      foldl1 (liftM2 strcat) (Cons title (Cons (return s_comma) (Cons (return s_authors) (Cons (liftM toString authors') Nil))))) pids
      --                     ^ [title, ", ", "authors: ", toString authors']

-- Print information about a bunch of papers to session user
test7 :: World -> (List PaperId) -> World
test7 = \w. \allPids .
  let u = getSessionUser w in
  foldl (\w. \s. print w u s) w (selectFrom w u allPids)

-- Print all papers to session user
test8 :: World -> World
test8 = \w.
  let u = getSessionUser w in
  let allPids = getAllPapers w in
  foldl (\w. \s. print w u s) w (selectFrom w u allPids)
  
forM_ :: <ap :: User -> Bool> .
   w: World -> l: Tagged (List (Tagged a <ap>)) <ap> -> f: (World -> (Tagged a <ap>) -> World) -> World

-- Print all session user's papers
test9 :: World -> World
test9 = \w.
  let u = getSessionUser w in
  let ownPids {- :: [PaperId]<> -} =
     filterM (\pid. liftM2 elem u (ifM (liftM2 elem u (getPaperAuthors w pid))
                                      (getPaperAuthors w pid) (return Nil)))
             (getAllPapers w) in
  forM_ w (liftM (\l. selectFrom w u l) ownPids) (\w. \s. print w u s)
  --              ^ [PaperId]->[String<>]  ^ [PaperId]<>
  --       ^ [String<>]<>


-- TODO unconflicted papers (for bidding)
-- liftM not (liftM2 elem u (getPaperConflicts w pid)))
