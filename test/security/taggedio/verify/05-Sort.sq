{- Sorting by sensitive value + negative self-referential policies -}

{- Datatypes -}

data Store

data PaperId

{- Sensitive data and policies -}

-- | Paper title (public)
getPaperTitle :: ds: Store -> p: PaperId -> TIO String <{True}> <{False}>

-- | Paper conflicts (public)
predicate paperConflicts :: Store -> Map PaperId (Set User)
getPaperConflicts :: ds: Store -> pid: PaperId 
                        -> TIO {List User | elems _v == (paperConflicts ds)[[pid]]} <{!(_0 in (paperConflicts ds)[[pid]])}> <{False}>

-- | Paper score (only visible if not in conflict)
getPaperScore :: ds: Store -> pid: PaperId -> TIO Int <{!(_0 in (paperConflicts ds)[[pid]])}> <{False}>

-- | All papers in the conference
getAllPaperIds :: ds: Store -> TIO [PaperId] <{True}> <{False}>

{- Client code -}
  
-- | Sort papers by their score.
-- | Repair: inside cmpScore, check that client is not conflicted with pid1/2
sortPapersByScore :: Store -> User -> TIO Unit <{False}> <{True}>
sortPapersByScore = \ds . \client .
  let notConflicted = \pid . downgrade (
                               do
                                 cs <- getPaperConflicts ds pid
                                 return (not (elem client cs))) in
  let cmpScore = \pid1. \pid2.
                  do 
                     isConflicted1 <- notConflicted pid1
                     x1 <- if isConflicted1
                            then getPaperScore ds pid1
                            else return 0
                     isConflicted2 <- notConflicted pid2
                     x2 <- if isConflicted2
                            then getPaperScore ds pid2
                            else return 0
                     return (x1 <= x2) in
  do pids <- getAllPaperIds ds
     sortedPids <- sortByM cmpScore pids
     titles <- mapM (getPaperTitle ds) sortedPids
     print client (unlines titles)
