{- Auction: nontrivial redaction -}

{- Datatypes -}

data Store

data Phase where
  Bidding :: Phase
  Done :: Phase  
guard {Bidding, Done}

{- Sensitive data and policies -}   

getAllParticipants :: ds: Store -> [User]

-- | Auction phase (public)
predicate phase :: Store -> Phase
getPhase :: ds: Store -> TIO {Phase | _v == phase ds} <{True}> <{False}>

-- | User bid (fully visible to the user themselves and once the phase is done; partially visible to all users who have bid)
predicate hasBid :: Store -> Map User Bool
getBid :: ds: Store -> u: User -> 
  TIO { Maybe (TIO Int <{ phase ds == Done || _0 == u }> <{False}>) | just _v == (hasBid ds)[[u]] } 
    <{ phase ds == Done || _0 == u || (hasBid ds)[[_0]]}> <{False}>    
  
{- Client code -}  
  
-- | Show bids of all participants to `client`
-- | Repair: for getBid, check that phase is done or client is p,
--           otherwise check that client has bid, then apply `fmap (const 0)`
--           otherwise return Nothing
showBids :: Store -> User -> TIO Unit <{False}> <{True}>
showBids = \ds . \client .
  let showParticipant = \p . 
    do 
       ph <- getPhase ds       
       mB <- if ph == Done || client == p
               then getBid ds p
               else do
                     mMyBid <- getBid ds client                
                     if isJust mMyBid
                       then liftM (\mBid . fmap mBid (\x . return 0)) (getBid ds p)
                       else return Nothing
       maybe (return emptyString) (\x . liftM show x) mB in
  do
    rows <- mapM showParticipant (getAllParticipants ds)
    print client (unlines rows)    
  