{- Primitives -}
true :: {Bool | _v}
false :: {Bool | !_v}
eq :: x: a -> y: a -> {Bool | _v == (x == y)}
not :: x: Bool -> {Bool | _v == !x}
and :: x: Bool -> y: Bool -> {Bool | _v == (x && y)}

zero :: {Int | _v == 0}
leq :: x: Int -> y: Int -> {Bool | _v == (x <= y)}

{- Unit -}

data Unit where
  Unit :: Unit

{- Lists -}

data List a where
	Nil :: List a
	Cons :: x: a -> xs: List a -> List a
  
termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs
  
measure elems :: List a -> Set a where
  Nil -> []
  Cons x xs -> [x] + elems xs
  
head :: {List a | len _v > 0} -> a
head = \xs .
  match xs with
    Nil -> error
    Cons y ys -> y
    
length :: xs : [a] -> {Int | _v == len xs}
length = \xs .
  match xs with
    Nil -> 0
    Cons y ys -> 1 + length ys
    
elem :: x: a -> xs: List a -> {Bool | _v == (x in elems xs)}  
elem = \x . \xs . 
  match xs with
    Nil -> False
    Cons y ys -> eq x y || elem x ys
    
sameElems :: x: List a -> y: List a -> {Bool | _v == (elems x == elems y)}
disjoint :: xs: List a -> ys: List a -> {Bool | _v <==> (elems xs * elems ys == [])}

map :: (a -> b) -> xs: [a] -> [b]
map = \f . \xs .
  match xs with 
    Nil -> Nil
    Cons y ys -> Cons (f y) (map f ys)

-- foldr :: (a -> b -> b) -> b -> [a] -> b
-- foldr = \f . \z . \xs .
  -- match xs with
    -- Nil -> z
    -- Cons y ys -> f y (foldr f z ys)

remove :: a -> [a] -> [a]
remove = \x . \xs .
  match xs with
    Nil -> Nil
    Cons y ys -> if x == y
                   then remove x ys
                   else Cons y (remove x ys)                   
    
{- Maybe -}

data Maybe a where
  Nothing :: Maybe a
  Just :: a -> Maybe a
  
measure just :: Maybe a -> Bool where
  Nothing -> False
  Just x -> True
  
fmap :: Maybe a -> (a -> b) -> Maybe b
fmap = \mb . \f . 
  match mb with
    Nothing -> Nothing
    Just x -> Just (f x)  
  
isJust :: x:Maybe a -> {Bool | _v == just x}

maybe :: b -> (a -> b) -> Maybe a -> b
maybe = \v . \f . \mX .
  match mX with
    Nothing -> v
    Just x -> f x
    
{- Strings -}

data String
emptyString :: String
show :: a -> String
strcat :: String -> String -> String
unwords :: [String] -> String
unlines :: [String] -> String
