{- Primitives -}
true :: {Bool | _v}
false :: {Bool | !_v}
eq :: x: a -> y: a -> {Bool | _v == (x == y)}
not :: x: Bool -> {Bool | _v == !x}

zero :: {Int | _v == 0}
leq :: x: Int -> y: Int -> {Bool | _v == (x <= y)}

{- Unit -}

data Unit where
  Unit :: Unit

{- Lists -}

data List a where
	Nil :: List a
	Cons :: x: a -> xs: List a -> List a
  
termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs
  
measure elems :: List a -> Set a where
  Nil -> []
  Cons x xs -> [x] + elems xs
  
elem :: x: a -> xs: List a -> {Bool | _v == (x in elems xs)}  
elem = \x . \xs . 
  match xs with
    Nil -> False
    Cons y ys -> eq x y || elem x ys
    
sameElems :: x: List a -> y: List a -> {Bool | _v == (elems x == elems y)}
disjoint :: xs: List a -> ys: List a -> {Bool | _v <==> (elems xs * elems ys == [])}

map :: (a -> b) -> xs: [a] -> [b]
map = \f . \xs .
  match xs with 
    Nil -> Nil
    Cons y ys -> Cons (f y) (map f ys)

-- foldr :: <p :: List a -> b -> Bool> .
		-- f: (xs: List a -> x: a -> acc: {b | p xs _v} -> {b | p (Cons x xs) _v}) ->
		-- seed: {b | p Nil _v} ->
    -- ys: List a ->    
		-- {b | p ys _v}
    
{- Maybe -}

data Maybe a where
  Nothing :: Maybe a
  Just :: a -> Maybe a
  
measure just :: Maybe a -> Bool where
  Nothing -> False
  Just x -> True
  
fmap :: Maybe a -> (a -> b) -> Maybe b
-- fmap = \f . \mb . 
  -- match mb with
    -- Nothing -> Nothing
    -- Just x -> Just (f x)  
  
isJust :: x:Maybe a -> {Bool | _v == just x}

maybe :: b -> (a -> b) -> Maybe a -> b
maybe = \v . \f . \mX .
  match mX with
    Nothing -> v
    Just x -> f x
    
{- Strings -}

data String
emptyString :: String
show :: a -> String
strcat :: String -> String -> String
unwords :: [String] -> String
unlines :: [String] -> String
length :: [a] -> Int
