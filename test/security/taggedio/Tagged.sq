{- Tagged -}

data User

-- | Computation with a label and clearance
data TIO a <label :: User -> Bool>- <clear :: User -> Bool>

return :: x: a -> TIO a <{True}> <{False}>

-- | Moral type of bind:
-- bind :: <p :: User -> Bool> . <q :: User -> Bool> . <r :: User -> Bool> . 
  -- x: TIO a <p> <q> 
  -- -> (u: a -> TIO b <r> <p>) 
  -- -> TIO b <{p _0 && r _0}> <{q _0 || p _0}>
  
-- | (>>=)
-- | Actual type of bind is its moral type + subtyping
bind :: <p :: User -> Bool> . <q :: User -> Bool> . <r :: User -> Bool> . <s :: User -> Bool> . 
  x: TIO a <p> <q> 
  -> (u: a -> TIO b <r> <{p _0 && s _0}>) 
  -> TIO b <{p _0 && r _0}> <{q _0 || (p _0 && s _0)}>  
  
-- | (>>)  
seq :: <p :: User -> Bool> . <q :: User -> Bool> . <r :: User -> Bool> . <s :: User -> Bool> . 
  x: TIO a <p> <q> 
  -> TIO b <r> <s>
  -> TIO b <r> <{q _0 || s _0}>
  
-- | Allow someone to see a boolean that is always false whenever they cannot see it
downgrade :: <bp :: User -> Bool> . <bc :: Bool> . <bq :: User -> Bool> .
  x: TIO {Bool | _v ==> bc} <{bp _0 && bc}> <bq> -> TIO {Bool | _v ==> bc} <bp> <bq>
  
{- Standard monadic helper functions -}

-- | For simplicity these are defined over TIOs with no write effects
-- but this can be easily changed
liftM :: <lp :: User -> Bool> . (a -> b) -> TIO a <lp> <{False}> -> TIO b <lp> <{False}>
liftM = \f . \t .
  do
    x <- t
    return (f x)
    
liftM2 :: <lp :: User -> Bool> . 
  (a -> b -> c) -> TIO a <lp> <{False}> -> TIO b <lp> <{False}> -> TIO c <lp> <{False}>
liftM2 = \f . \t1 . \t2 .
  do
    x <- t1
    y <- t2
    return (f x y)

sequence :: <seqp :: User -> Bool> . xs: [TIO a <seqp> <{False}>] -> TIO [a] <seqp> <{False}>
sequence = \xs .
  match xs with
    Nil -> return Nil
    Cons y ys -> liftM2 Cons y (sequence ys)    
    
mapM :: <mp :: User -> Bool> . 
  (a -> TIO b <mp> <{False}>) -> xs: [a] -> TIO [b] <mp> <{False}>
mapM = \f . \xs . sequence (map f xs)

filterM :: <fp :: User -> Bool> . <fc :: a -> Bool> .
  (x: a -> TIO {Bool | _v ==> fc x} <{fc x && fp _0}> <{False}>) -> xs: [a] -> TIO [{a | fc _v}] <fp> <{False}>
filterM = \f . \xs .
  match xs with
    Nil -> return Nil
    Cons y ys -> do    
                   c <- downgrade (f y)
                   if c
                      then liftM2 Cons (return y) (filterM f ys)
                      else filterM f ys

{- auxiliary function for sortByM (below) -}
insertM :: <inp :: User -> Bool> . (a -> a -> TIO Bool <inp> <{False}>) -> x: a -> xs: List a -> TIO {List a | elems _v == elems xs + [x]} <inp> <{False}>
insertM = \isLeq . \x . \xs .
  match xs with
    Nil -> return [x]
    Cons y ys -> 
      do
        c <- isLeq x y 
        if c
          then return (Cons x xs)
          else do
                rec <- insertM isLeq x ys
                return (Cons y rec)
    
sortByM :: <sop :: User -> Bool> .
  (a -> a -> TIO Bool <sop> <{False}>) -> xs: [a] -> TIO {List a | elems _v == elems xs} <sop> <{False}>
sortByM = \isLeq . \xs .  
  match xs with
    Nil -> return Nil
    Cons y ys -> do 
                   rec <- sortByM isLeq ys
                   insertM isLeq y rec

{- Output -}      

print :: viewer: User -> msg: String -> TIO Unit <{True}> <{_0 == viewer}>

-- | Print to all viewers
printAll :: viewers: List User -> msg: String -> TIO Unit <{True}> <{_0 in elems viewers}>
printAll = \viewers . \msg .
  match viewers with
    Nil -> return Unit
    Cons v vs -> 
      do
        print v msg    
        printAll vs msg

{- Guards, redaction functions, and qualifiers -}

redact {false, zero, Nil, Nothing, fmap, emptyString}

guard {true, eq, not, leq, elem, sameElems, disjoint, isJust}

qualifier {x == y, x in y, !(x in y), x == []}
