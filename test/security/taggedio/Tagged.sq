{- TIO Primitives -}

data User

-- | Computation with an input and an output label
data TIO a <inl :: User -> Bool>- <outl :: User -> Bool>

return :: x: a -> TIO a <{True}> <{False}>
  
-- | (>>=)
-- | Actual type of bind is its moral type + subtyping
bind :: <i :: User -> Bool> . <o :: User -> Bool> . <j :: User -> Bool> . <p :: User -> Bool> . 
  TIO a <i> <o> 
  -> (u: a -> TIO b <j> <{i _0 && p _0}>) 
  -> TIO b <{i _0 && j _0}> <{o _0 || (i _0 && p _0)}>  
    
-- | Allow someone to see a boolean that is always false whenever they cannot see it
downgrade :: <bp :: User -> Bool> . <bc :: Bool> . <bq :: User -> Bool> .
  x: TIO {Bool | _v ==> bc} <{bp _0 && bc}> <bq> -> TIO {Bool | _v ==> bc} <bp> <bq>
  
{- TIO Auxiliary functions -}

-- | (>>)  
seq :: <si :: User -> Bool> . <so :: User -> Bool> . <sj :: User -> Bool> . <sp :: User -> Bool> . 
  TIO a <si> <so> 
  -> TIO b <sj> <sp>
  -> TIO b <sj> <{so _0 || sp _0}>
seq = \a1 . \a2 .
  do
    x <- downgrade (bind a1 (\y . return False))
    a2

liftM :: <lp :: User -> Bool> . <lq :: User -> Bool> . (a -> b) -> TIO a <lp> <lq> -> TIO b <lp> <lq>
liftM = \f . \t .
  do
    x <- t
    return (f x)
    
liftM2 :: <lp :: User -> Bool> . <lq :: User -> Bool> . <lr :: User -> Bool> . <ls :: User -> Bool> .
  (a -> b -> c) -> TIO a <lp> <lq> -> TIO b <lr> <{lp _0 && ls _0}> -> TIO c <{lp _0 && lr _0}> <{lq _0 || (lp _0 && ls _0)}>
liftM2 = \f . \t1 . \t2 .
  do
    x <- t1
    y <- t2
    return (f x y)

sequence :: <seqp :: User -> Bool> . xs: [TIO a <seqp> <seqp>] -> TIO [a] <seqp> <seqp>
sequence = \xs .
  match xs with
    Nil -> return Nil
    Cons y ys -> liftM2 Cons y (sequence ys)    
    
mapM :: <mp :: User -> Bool> . 
  (a -> TIO b <mp> <mp>) -> xs: [a] -> TIO [b] <mp> <mp>
mapM = \f . \xs . sequence (map f xs)

forM_ :: <mq :: User -> Bool> . 
  xs: [a] -> (a -> TIO b <{False}> <mq>) -> TIO Unit <{True}> <mq>
forM_ = \xs . \f . 
  match xs with
    Nil -> return Unit
    Cons y ys -> seq (f y) (forM_ ys f)

filterM :: <fp :: User -> Bool> . <fc :: a -> Bool> .
  (x: a -> TIO {Bool | _v ==> fc x} <{fc x && fp _0}> <{False}>) -> xs: [a] -> TIO [{a | fc _v}] <fp> <{False}>
filterM = \f . \xs .
  match xs with
    Nil -> return Nil
    Cons y ys -> do    
                   c <- downgrade (f y)
                   if c
                      then liftM2 Cons (return y) (filterM f ys)
                      else filterM f ys

{- auxiliary function for sortByM (below) -}
insertM :: <inp :: User -> Bool> . (a -> a -> TIO Bool <inp> <{False}>) -> x: a -> xs: List a -> TIO {List a | elems _v == elems xs + [x] && len _v == len xs + 1} <inp> <{False}>
insertM = \isLeq . \x . \xs .
  match xs with
    Nil -> return [x]
    Cons y ys -> 
      do
        c <- isLeq x y 
        if c
          then return (Cons x xs)
          else do
                rec <- insertM isLeq x ys
                return (Cons y rec)
    
sortByM :: <sop :: User -> Bool> .
  (a -> a -> TIO Bool <sop> <{False}>) -> xs: [a] -> TIO {List a | elems _v == elems xs && len _v == len xs} <sop> <{False}>
sortByM = \isLeq . \xs .  
  match xs with
    Nil -> return Nil
    Cons y ys -> do 
                   rec <- sortByM isLeq ys
                   insertM isLeq y rec

{- Output -}      

print :: viewer: User -> msg: String -> TIO Unit <{True}> <{_0 == viewer}>

-- | Print to all viewers
printAll :: viewers: List User -> msg: String -> TIO Unit <{True}> <{_0 in elems viewers}>
printAll = \viewers . \msg .
  match viewers with
    Nil -> return Unit
    Cons v vs -> 
      do
        print v msg    
        printAll vs msg

{- Guards, redaction functions, and qualifiers -}

redact {false, zero, Nil, Nothing, fmap, emptyString}

guard {true, eq, not, leq, elem, sameElems, disjoint, isJust}

qualifier {x == y, x in y, !(x in y), x == []}
