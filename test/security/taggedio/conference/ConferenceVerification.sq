
-- Strings

s_success :: String
s_colon :: String
s_comma :: String
s_paperNo :: String
s_authors :: String
s_qmark :: String

-- | Create a user (open to all)
registerUser :: w: World -> u: User -> pw: String -> TIO Unit <{False}> <{True}>
registerUser = \w . \u . \pw . 
  do
    addUser w u pw
    print u s_success

-- | Show all users (only pc chair can see!)
usersView :: World -> TIO Unit <{False}> <{True}>
usersView = \w .
  do
    u <- getSessionUser w
    chair <- getChair w
    users <- if u == chair then getUsers w else return []
    print u (show users)

-- | Submit paper
submitForm :: World -> String -> [User] -> [User] -> TIO Unit <{False}> <{True}>
submitForm = \w . \title . \authors . \conflicts .
  do
    pid <- getFreshPaperId w
    w1 <- addPaper w pid
    w2 <- setPaperTitle w1 pid title
    w3 <- setPaperAuthors w2 pid authors
    setPaperConflicts w3 pid conflicts
    return Unit
    

-- | Search papers
searchForm :: World -> (User -> [User] -> Bool) -> Maybe User -> Maybe User -> TIO Unit <{False}> <{True}>
searchForm = \w . \userFilter . \byAuthor . \byReviewer .
  let authorFilter = \u . \pid . \author.
        do
          inAuts <- downgrade (
            do 
              as <- getPaperAuthors w pid
              return (elem u as))
          if inAuts
            then do
                  auts <- getPaperAuthors w pid
                  return (userFilter author auts)
            else return False in
  let revFilter = \u . \pid . \rev .
        do
          noConflict <- downgrade (
            do 
              cs <- getPaperConflicts w pid
              return (!(elem u cs))) 
          pc <- getPC w
          if elem u pc && noConflict
            then do
                  revs <- getPaperReviewers w pid
                  return (userFilter rev revs)
            else return False in                            
  do
    allPids <- getAllPapers w
    u <- getSessionUser w
    pids <- filterM (\pid . do
                              b1 <- maybe (return True) (authorFilter u pid) byAuthor
                              b2 <- maybe (return True) (revFilter u pid) byReviewer
                              return (b1 && b2)) allPids
    print u (unlines (map show pids))

-- | Show paper record
paperView :: World -> PaperId -> TIO Unit <{False}> <{True}>
paperView = \w. \pid .
  do
    u <- getSessionUser w
    noConflict <- downgrade (
      do 
        cs <- getPaperConflicts w pid
        return (!(elem u cs)))
    title <- if noConflict then getPaperTitle w pid else return emptyString
    inAuts <- downgrade (
      do 
        as <- getPaperAuthors w pid
        return (elem u as))
    authors <- if inAuts then getPaperAuthors w pid else return []
    conflicts <- if noConflict then getPaperConflicts w pid else return []
    print u (unwords [title, show authors, show conflicts])
  
-- emptyReview :: Tagged Review <{True}>
-- emptyReview = return (ReviewEntry emptyString emptyString (ReviewScoresEntry 0 0 0 0))  

-- nobody :: Tagged Reviewer <{True}>

-- -- Show reviews for paper
-- reviewsView :: World -> PaperId -> World
-- reviewsView = \w. \pid.
  -- let u = getSessionUser w in
  -- let allRids = getAllReviews w in
  -- let rids =
    -- filterM (\rid . bind (getReviewPaper w rid) (\p. return (p == pid))) allRids in
  -- print w u (liftM show (bind rids (\rids'. (mapM (\rid .
   -- bind (ifM (andM (bind (getReviewPaper w rid) (\x. return (pid == x)))
                   -- (bind u (\u0. bind (getReviewPaper w rid) (\pid0. 
                    -- bind (getPaperAuthors w pid)
                       -- (\authors0. return (elem u0 authors0)))))) (getReview w rid) emptyReview) (\rev.
   -- bind (ifM (bind u (\u0. bind (getChair w) (\ch. return (u0 == ch)))) (getReviewAuthor w rid) (anonymousReviewer (getReviewAuthor w rid))) (\auth. return [show rev, show auth]))) rids'))))

-- -- View/change profile
-- profileViewGet :: World -> World
-- profileViewGet = \w .
  -- let u = getSessionUser w in
  -- let profile = bind u (\u' . getUserProfile w u') in
  -- let profile_str = 
    -- bind profile (
      -- \profile' . match profile' with
                   -- UserProfileRecord nam aff acm email -> return (foldl1 strcat [nam, s_comma, aff, s_comma, acm, s_comma, email])) in
  -- print w u profile_str

-- profileViewPost :: World -> UserProfile -> World
-- profileViewPost = \w . \profile .
  -- let u = getSessionUser w in
  -- setUserProfile w (peel u) (return profile)

-- -- Submit a review
-- submitReviewViewPost :: World -> PaperId -> Review -> World
-- submitReviewViewPost = \w . \pid . \rev .
  -- let u = getSessionUser w in
  -- let rid = getFreshReviewId w in
  -- let allRids = getAllReviews w in
  -- let existingRids =
    -- filterM (\rid . bind (getReviewPaper w rid) (\p. return (p == pid))) allRids in
  -- let rauth = do u' <- u
                 -- l <- existingRids
                 -- return (ReviewerEntry (length l) u') in
  -- let w1 = setReviewAuthor w rid rauth in
  -- let w2 = setReviewPaper w1 rid (return pid) in
  -- let w3 = setReview w2 rid (return rev) in
  -- w3

-- -- Assigns papers to a reviewer
-- assignReviewersView :: World -> User -> [PaperId] -> World
-- assignReviewersView = \w . \reviewer . \pids .
  -- let allPids = getAllPapers w in
  -- foldl (\w' . \pid . setPaperReviewers w' pid (bind (getPaperReviewers w' pid) (\l.
    -- return (insertIf (elem pid pids) reviewer (remove reviewer l))))) w allPids

remove :: a -> List a -> List a

insertIf :: Bool -> a -> List a -> List a

