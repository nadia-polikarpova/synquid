-- Conference management

data World

data PaperId

data Phase where
  Submission :: Phase
  Review :: Phase
  Done :: Phase
  
guard {Submission, Review, Done}

data Status where
  NoDecision :: Status
  Accepted :: Status
  Rejected :: Status
  
guard {Submission, Review, Done}
redact {NoDecision}

data ReviewId

data ReviewScores where
  ReviewScoresEntry :: novelty: Int -> presentation: Int -> technical: Int -> confidence: Int -> ReviewScores
  
redact {ReviewScoresEntry}  

data Reviewer where
  ReviewerEntry :: idx: Int -> user: User -> Reviewer

measure ruser :: Reviewer -> User where
  ReviewerEntry i u -> u

anonymousReviewer :: TIO Reviewer <{False}> <{False}> -> TIO Reviewer <{True}> <{False}>
redact {anonymousReviewer}

data Review where
  ReviewEntry :: time: String -> contents: String -> scores: ReviewScores -> Review
  
redact {ReviewEntry}

data UserProfile where
  UserProfileRecord :: name: String -> affiliation: String -> acm_number: String -> email: String -> UserProfile
  
redact {UserProfileRecord}    

data Token

getCurrentWorld :: TIO World <{True}> <{False}>

predicate users :: World -> Set User
getUsers :: w: World -> TIO {List {User | _v in users w} | elems _v == users w} <{_0 == chair w}> <{False}>

getPassword :: w: World -> u: User -> TIO String <{_0 == u}> <{False}>
setPassword :: w: World -> u: User -> pw: String -> TIO Unit <{True}> <{_0 == u}>

addUser :: w: World -> u: User -> pw: String -> 
  TIO World <{True}> <{True}>

predicate userProfiles :: World -> Map User UserProfile
getUserProfile :: w: World -> u: User -> TIO {UserProfile | _v == (userProfiles w)[[u]]} <{_0 == u || _0 == chair w}> <{False}>
setUserProfile :: w: World -> u: User -> UserProfile -> TIO Unit <{True}> <{_0 == u || _0 == chair w}>

predicate sessionUser :: World -> User
getSessionUser :: w: World -> TIO {User | _v == sessionUser w} <{True}> <{False}>

predicate chair :: World -> User
getChair :: w: World -> TIO {User | _v == chair w} <{True}> <{False}>

predicate pc :: World -> Set User
getPC :: w: World -> TIO {List {User | _v in pc w} | elems _v == pc w} <{True}> <{False}>

predicate currentPhase :: World -> Phase
getCurrentPhase :: w: World -> TIO {Phase | _v == currentPhase w} <{True}> <{False}>

predicate paperConflicts :: World -> PaperId -> Set User
getPaperConflicts :: w: World -> pid: PaperId
   -> TIO {List {User | _v in paperConflicts w pid} | elems _v == paperConflicts w pid} <{!(_0 in paperConflicts w pid)}> <{False}>
setPaperConflicts ::  w: World -> pid: PaperId
   -> [User]
   -> TIO Unit <{True}> <{!(_0 in paperConflicts w pid)}>

getPaperTitle :: w: World -> pid: PaperId 
   -> TIO String <{ !(_0 in paperConflicts w pid) }> <{False}>
setPaperTitle :: w: World -> pid: PaperId
   -> String
   -> TIO Unit <{True}> <{!(_0 in paperConflicts w pid)}>

predicate paperAuthors :: World -> Map PaperId (Set User)
getPaperAuthors :: w: World -> pid: PaperId 
   -> TIO {List {User | (_v in (paperAuthors w)[[pid]]) && !(_v in paperConflicts w pid)} | elems _v == (paperAuthors w)[[pid]]} 
             <{_0 in (paperAuthors w)[[pid]] }> <{False}>
setPaperAuthors :: w: World ->  pid: PaperId 
   -> [User]
   -> TIO Unit <{True}> <{_0 in (paperAuthors w)[[pid]] }>


predicate paperStatus :: World -> PaperId -> Status
getPaperStatus :: w: World -> pid: PaperId -> TIO {Status | _v == paperStatus w pid} <{_0 == chair w || (currentPhase w == Done && _0 in (paperAuthors w)[[pid]] )}> <{False}>

getPaperSession :: w: World -> pid: PaperId -> TIO String <{True}> <{False}>

getAllPapers :: w: World -> TIO [PaperId] <{True}> <{False}>

getFreshPaperId :: w: World -> TIO PaperId <{True}> <{False}>
addPaper :: w: World -> newId: PaperId -> TIO Unit <{True}> <{True}>

predicate paperReviewers :: World -> Map PaperId (Set User)
getPaperReviewers :: w: World -> pid: PaperId 
   -> TIO {List {User | (_v in (paperReviewers w)[[pid]]) && !(_v in paperConflicts w pid)} | elems _v == (paperReviewers w)[[pid]]} 
             <{_0 in pc w && !(_0 in (paperConflicts w pid)) }> <{False}>
setPaperReviewers :: w: World ->  pid: PaperId 
   -> [User]
   -> TIO Unit <{True}> <{_0 in pc w && !(_0 in (paperConflicts w pid)) }>


predicate reviewAuthor :: World -> Map ReviewId Reviewer
getReviewAuthor :: w: World -> rid: ReviewId -> TIO {Reviewer | _v == (reviewAuthor w)[[rid]]} <{_0 == chair w}> <{False}>
--   I want this:   <{_1 == chair _0 || _1 == ruser ((reviewAuthor _0)[[rid]])}>
setReviewAuthor :: w: World -> rid: ReviewId -> Reviewer -> TIO Unit <{True}> <{_0 == chair w}>

predicate reviewPaper :: World -> Map ReviewId PaperId
getReviewPaper :: w: World -> rid: ReviewId -> TIO {PaperId | _v == (reviewPaper w)[[rid]]} <{True}> <{False}>
setReviewPaper :: w: World -> rid: ReviewId -> PaperId -> TIO Unit <{True}> <{True}>

predicate reviews :: World -> Map ReviewId Review
getReview :: w: World -> rid: ReviewId -> TIO {Review | _v == (reviews w)[[rid]]} <{_0 in (paperAuthors w)[[ (reviewPaper w)[[rid]] ]]}> <{False}>
setReview :: w: World -> rid: ReviewId -> Review -> TIO Unit <{True}> <{_0 in (paperAuthors w)[[ (reviewPaper w)[[rid]] ]]}>

getAllReviews :: w: World -> TIO [ReviewId] <{True}> <{False}>

getFreshReviewId :: w: World -> TIO ReviewId <{True}> <{False}>

getPaperBidToken :: w: World -> pid: PaperId -> TIO (Maybe Token) <{ {- !(_1 in (paperAuthors _0)[[pid]]) && -} (_0 in pc w) && !(_0 in paperConflicts w pid) }> <{False}>

{- Some Strings -}

s_delighted :: String
s_regret :: String

{- Extra combinators -}

foldl :: (a -> b -> a) -> a -> (List b) -> a
foldl1 :: f: (a -> a -> a) -> l: List a -> a

ifJust :: (Maybe a) -> (a -> b) -> b

-- TODO currently there has to be something here, otherwise nothing gets emitted

elemMaybe :: x: a -> xs: Maybe [a] -> Bool
elemMaybe = \x. \xs.
  match xs with
    Just l -> elem x l
    Nothing -> 0 == 0
