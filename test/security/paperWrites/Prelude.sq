{- Primitives -}

-- true :: {Bool | _v}
-- false :: {Bool | !_v}
eq :: x: a -> y: a -> {Bool | _v == (x == y)}
not :: x: Bool -> {Bool | _v == !x}

leq :: x: Int -> y: Int -> {Bool | _v == (x <= y)}

{- Lists -}

data List a where
	Nil :: List a
	Cons :: x: a -> xs: List a -> List a
  
termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs
  
measure elems :: List a -> Set a where
  Nil -> []
  Cons x xs -> [x] + elems xs
  
elem :: x: a -> xs: List a -> {Bool | _v == (x in elems xs)}  
-- elem = \x . \xs . 
  -- match xs with
    -- Nil -> False
    -- Cons y ys -> eq x y || elem x ys
    
-- sameElems :: x: List a -> y: List a -> {Bool | _v == (elems x == elems y)}
-- disjoint :: xs: List a -> ys: List a -> {Bool | _v <==> (elems xs * elems ys == [])}

-- foldr :: <p :: List a -> b -> Bool> .
		-- f: (xs: List a -> x: a -> acc: {b | p xs _v} -> {b | p (Cons x xs) _v}) ->
		-- seed: {b | p Nil _v} ->
    -- ys: List a ->    
		-- {b | p ys _v}