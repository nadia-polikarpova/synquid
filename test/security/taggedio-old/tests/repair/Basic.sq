{-
  This example assumes that all users are either PC members or chair,
  and only chair can see paper authors
-}

{- Datatypes -}

data PaperId
data World

{- Sensitive data and policies -}

getWorld :: TaggedIO World <{True}>
   
-- | Current session user
predicate sessionUser :: User      
getSessionUser :: TaggedIO (Tagged {User | _v == sessionUser} <{True}>) <{True}>

-- | PC chair (public)
predicate chair :: World -> User
getChair :: w: World -> Tagged {User | _v == chair w} <{True}>

-- | Paper title (public)
getPaperTitle :: w: World -> pid: PaperId -> Tagged String <{True}>

-- | Paper authors (visible only to the chair)
getPaperAuthors :: w: World -> pid: PaperId -> Tagged (List User) <{_0 == chair w}>

{- Client code -}
  
-- | Show paper info to session user
-- | Repair: check that u is chair
showPaper :: pid: PaperId -> TaggedIO Unit <{True}>
showPaper = \pid .
	bindIO getWorld (\w .
	bindIO getSessionUser (\u .
  let title = getPaperTitle w pid in
  let authors = liftM show (getPaperAuthors w pid) in
  let out = liftM2 strcat title authors in
  print u out
	)
	)

-- repair should look like:
{-
showPaper :: pid: PaperId -> TaggedIO Unit <{True}>
showPaper = \pid .
	bindIO getWorld (\w .
	bindIO getSessionUser (\u .
  let title = getPaperTitle w pid in
  let authors = liftM show (bind (liftM2 eq (getChair w) u) (\c . if c then
                                (getPaperAuthors w pid) else
                                (return Nil))) in
  let out = liftM2 strcat title authors in
  print u out
	)
	)
-}
