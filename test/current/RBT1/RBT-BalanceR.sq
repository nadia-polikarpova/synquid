qualifier {x == 0}

black :: {Int | _v == 1}

data RBT a where
    Empty :: RBT a
    Node  :: x: a ->
             col: {Int | 0 <= _v && _v <= 1} ->
             left:  { RBT {a | _v < x} | isOk _v && (col == 0 ==> color _v == 1) } ->   -- left keys are less than this key; a red node must have black children
             right: { RBT {a | x < _v} | isOk _v && (col == 0 ==> color _v == 1) &&     -- right keys are greater than this key; a red node must have black children
                                        (blackHeight _v == blackHeight left)} ->        -- blackHeight the same as of left
             RBT a
    Bad :: x: a ->
              lc:    {Int | 0 <= _v  && _v <= 1 } ->
              left:  { RBT {a | _v < x} | isOk _v && color _v == lc} ->
              right: { RBT {a | x < _v } | isOk _v && color _v != lc && blackHeight _v == blackHeight left} ->
              RBT a             
                      
termination measure size :: RBT a -> {Int | _v >= 0} where
  Empty -> 0
  Node x c l r -> 1 + size l + size r
  Bad x lc l r -> 1 + size l + size r
  
measure color :: RBT a -> {Int | 0 <= _v && _v <= 1} where
  Empty -> 1
  Node x c l r -> c
  Bad x lc left right -> 0
  
measure elems :: RBT a -> Set a where
  Empty -> []
  Node x c l r -> [x] + elems l + elems r
  Bad x lc l r -> [x] + elems l + elems r

measure blackHeight :: RBT a -> {Int | _v >= 0} where
  Empty -> 0
  Node x c l r -> c + blackHeight l
  Bad x lc l r -> blackHeight l
  
measure isOk :: RBT a -> Bool where
  Empty -> True
  Node x c left right -> True
  Bad x lc left right -> False  
  
rotateR :: x: a ->
        l: {RBT {a | _v < x} | isOk _v} ->
        rx: {a | x < _v} ->
        rlc: {Int | _v == 0 || _v == 1} ->
        rl: {RBT {a | x < _v && _v < rx} | isOk _v && color _v == rlc && blackHeight _v == blackHeight l} ->
        rr: {RBT {a | rx < _v} | isOk _v && color _v != rlc && blackHeight _v == blackHeight l} ->             
        {RBT a | isOk _v && color _v == 0 && elems _v == [x, rx] + elems l + elems rl + elems rr && blackHeight _v == blackHeight l + 1 && size _v == 2 + size l + size rl + size rr}        
rotateR = ??   
                    
balanceR :: x: a ->
        c: {Int | 0 <= _v  && _v <= 1} ->
        l: {RBT {a | _v < x} | isOk _v && (c == 0 ==> color _v == 1)} ->
        r: {RBT {a | _v > x} | size _v > 0 && (c == 0 ==> isOk _v) && blackHeight _v == blackHeight l} ->
        {RBT a | elems _v == [x] + elems l + elems r && 
                      blackHeight _v == blackHeight l + c && 
                      size _v == 1 + size l + size r &&
                      (isOk _v || c == 0)}
balanceR = ??                      
