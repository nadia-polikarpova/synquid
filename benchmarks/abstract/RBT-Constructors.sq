qualifier {x < y, x == y}

red   :: {Int | _v == 0}
black :: {Int | _v == 1}

measure size        :: RBT a -> {Int | _v >= 0}
measure elems       :: RBT a -> Set a
measure blackHeight :: RBT a -> Int

data RBT a <P :: Int -> Bool> decreases size where
    Empty :: color: {Int | _v == 1 && P _v} ->  
			{RBT a <P> | size _v == 0 && 
              elems _v == [] && 
              blackHeight _v == 0}        										 	-- black-height of nils is 0
    Node  :: x: a -> 
             color: {Int | (_v == 0 || _v == 1) && P _v} -> 
             left:    RBT {a | _v < x} <{ color == 1 || _0 == 1 }> ->               -- left keys are less than this key; a red node must have black children
             right: { RBT {a | _v > x} <{ color == 1 || _0 == 1 }> |               	-- right keys are greater than this key; a red node must have black children 
                                        (blackHeight _v == blackHeight left)} ->    -- blackHeight the same as of left
             {RBT a <P> | size _v == size left + size right + 1 && 
						  elems _v == elems left + elems right + [x] && 
                          (blackHeight _v == blackHeight left + color)         		-- black-height is black-height of sub + 1 in case the current node is black
                      }

--============================================================================
-- Constructors taking 1, 2, 3 nodes.
--
-- args used: -a=2
--============================================================================

singleton :: x: a -> {RBT a <{_0 == 0}> | elems _v == [x] && blackHeight _v == 0 }
singleton = ??

dupleton :: x: a -> y: a -> {RBT a <{True}> | elems _v == [x, y]}
dupleton = ??

tripleton :: x: a -> y: a -> z: a -> {RBT a <{True}> | elems _v == [x, y, z]}
tripleton = ??
