max2 :: (x:Int -> (y:Int -> {Int|_v >= x && _v >= y}))
max2 = \x . \y . if (>=) x y
  then x
  else y

max3 :: (x:Int -> (y:Int -> (z:Int -> {Int|(_v >= x && _v >= y) && _v >= z})))
max3 = \x . \y . \z . if (&&) ((>=) x y) ((>=) x z)
  then x
  else if (>=) y z
    then y
    else z

max4 :: (w:Int -> (x:Int -> (y:Int -> (z:Int -> {Int|((_v >= w && _v >= x) && _v >= y) && _v >= z}))))
max4 = \w . \x . \y . \z . if (&&) ((>=) w x) ((&&) ((>=) w y) ((>=) w z))
  then w
  else if (&&) ((>=) x y) ((>=) x z)
    then x
    else if (>=) y z
      then y
      else z

max5 :: (v:Int -> (w:Int -> (x:Int -> (y:Int -> (z:Int -> {Int|(((_v >= v && _v >= w) && _v >= x) && _v >= y) && _v >= z})))))
max5 = \v . \w . \x . \y . \z . if (&&) ((>=) v w) ((&&) ((>=) v x) ((&&) ((>=) v y) ((>=) v z)))
  then v
  else if (&&) ((>=) w x) ((&&) ((>=) w y) ((>=) w z))
    then w
    else if (&&) ((>=) x y) ((>=) x z)
      then x
      else if (>=) y z
        then y
        else z

add :: (x:{Int|_v >= 0} -> (y:{Int|_v >= 0} -> {Int|_v == x + y}))
add = \x . \y . if (>=) 0 y
  then x
  else if (>=) 0 x
    then y
    else inc (add x (dec y))

max2 :: <P :: Int -> Bool> . (x:{Int|P _v} -> (y:{Int|P _v} -> {Int|(P _v && _v >= x) && _v >= y}))
max2 = \x . \y . if (>=) x y
  then x
  else y

null :: <a> . (xs:List (a) -> {Bool|_v == (len xs == 0)})
null = \xs . match xs with
  Nil -> true
  Cons x3 x4 -> false

elem :: <a> . (x:a -> (xs:List (a) -> {Bool|_v == (x) in (elems xs)}))
elem = \x . \xs . match xs with
  Nil -> false
  Cons x3 x4 -> if (==) x3 x
    then true
    else elem x x4

stutter :: <a> . (xs:List (a) -> {List (a)|len _v == 2 * len xs})
stutter = \xs . match xs with
  Nil -> xs
  Cons x3 x4 -> Cons x3 (Cons x3 (stutter x4))

replicate :: <a> . (n:{Int|_v >= 0} -> (x:a -> {List (a)|len _v == n}))
replicate = \n . \x . if (>=) 0 n
  then Nil
  else Cons x (replicate (dec n) x)

append :: <a> . (xs:List (a) -> (ys:List (a) -> {List (a)|len _v == len xs + len ys}))
append = \xs . \ys . match ys with
  Nil -> xs
  Cons x4 x5 -> Cons x4 (append xs x5)

concat :: <a> . (xss:ListOfLists (a) -> {List (a)|len _v == sumLen xss})
concat = \xss . match xss with
  Nil2 -> Nil
  Cons2 x3 x4 -> append x3 (concat x4)

take :: <a> . (n:{Int|_v >= 0} -> (xs:{List (a)|len _v >= n} -> {List (a)|len _v == n}))
take = \n . \xs . match xs with
  Nil -> xs
  Cons x4 x5 -> if (>=) 0 n
    then Nil
    else Cons x4 (take (dec n) x5)

drop :: <a> . (n:{Int|_v >= 0} -> (xs:{List (a)|len _v >= n} -> {List (a)|len _v == len xs - n}))
drop = \n . \xs . if (<=) n 0
  then xs
  else match xs with
    Nil -> error
    Cons x4 x5 -> drop (dec n) x5

delete :: <a> . (x:a -> (xs:List (a) -> {List (a)|elems _v == (elems xs) - ([x])}))
delete = \x . \xs . match xs with
  Nil -> xs
  Cons x3 x4 -> if (==) x3 x
    then delete x x4
    else Cons x3 (delete x x4)

map :: <b> . <a> . (f:(_:a -> b) -> (xs:List (a) -> {List (b)|len _v == len xs}))
map = \f . \xs . match xs with
  Nil -> Nil
  Cons x3 x4 -> Cons (f x3) (map (\x19 . f x19) x4)

zipWith :: <c> . <b> . <a> . (f:(_:a -> (_:b -> c)) -> (xs:List (a) -> (ys:{List (b)|len _v == len xs} -> {List (c)|len _v == len xs})))
zipWith = \f . \xs . \ys . match xs with
  Nil -> Nil
  Cons x4 x5 -> match ys with
    Nil -> error
    Cons x8 x9 -> Cons (f x4 x8) (zipWith (\x26 . \x27 . f x26 x27) x5 x9)

zip :: <b> . <a> . (xs:List (a) -> (ys:{List (b)|len _v == len xs} -> {List (Pair (a) (b))|len _v == len xs}))
zip = \xs . \ys . match xs with
  Nil -> Nil
  Cons x4 x5 -> match ys with
    Nil -> error
    Cons x8 x9 -> Cons (Pair x4 x8) (zip x5 x9)

toNat :: (xs:List (Int) -> {List ({Int|_v >= 0})|len _v == len xs})
toNat = \xs . map (\x6 . if (>=) x6 0
  then x6
  else neg x6) xs

product :: <b> . <a> . (la:List (a) -> (lb:List (b) -> {List (Pair (a) (b))|len _v == len la * len lb}))
product = \la . \lb . match la with
  Nil -> Nil
  Cons x4 x5 -> append (map (\x28 . Pair x4 x28) lb) (product x5 lb)

insert :: <a> . (x:a -> (xs:UList (a) -> {UList (a)|uelems _v == (uelems xs) + ([x])}))
insert = \x . \xs . match xs with
  UNil -> UCons x UNil
  UCons x9 x10 -> if (==) x9 x
    then xs
    else UCons x9 (insert x x10)

delete :: <a> . (x:a -> (xs:UList (a) -> {UList (a)|uelems _v == (uelems xs) - ([x])}))
delete = \x . \xs . match xs with
  UNil -> xs
  UCons x3 x4 -> if (==) x3 x
    then x4
    else UCons x3 (delete x x4)

delete :: <a> . (x:a -> (xs:UList (a) -> {UList (a)|uelems _v == (uelems xs) - ([x])}))
delete = \x . \xs . match xs with
  UNil -> xs
  UCons x3 x4 -> if (==) x3 x
    then x4
    else UCons x3 (delete x x4)

elem :: <a> . (x:a -> (xs:UList (a) -> {Bool|_v == (x) in (uelems xs)}))
elem = \x . \xs . match xs with
  UNil -> false
  UCons x3 x4 -> if (==) x3 x
    then true
    else elem x x4

strengthen :: <a> . (x:a -> (xs:{UList (a)|!(x) in (uelems _v)} -> {UList ({a|_v /= x})|uelems _v == uelems xs && ulen _v == ulen xs}))
strengthen = \x . \xs . match xs with
  UNil -> UNil
  UCons x3 x4 -> UCons x3 (strengthen x x4)

nub' :: <a> . (xs:List (a) -> (acc:UList (a) -> {UList (a)|uelems _v == (uelems acc) + (elems xs)}))
nub' = \xs . \acc . match xs with
  Nil -> acc
  Cons x3 x4 -> if elem x3 acc
    then nub' x4 acc
    else nub' x4 (UCons x3 (strengthen x3 acc))

compress :: <a> . (xs:List (a) -> {CList (a)|celems _v == elems xs})
compress = \xs . match xs with
  Nil -> CNil
  Cons x3 x4 -> match compress x4 with
    CNil -> CCons x3 CNil
    CCons x15 x16 -> if (==) x3 x15
      then CCons x15 x16
      else CCons x3 (CCons x15 x16)

elem :: <a> . (x:a -> (t:Tree (a) -> {Bool|_v == (x) in (telems t)}))
elem = \x . \t . match t with
  Empty -> false
  Node x4 x5 x6 -> if (==) x4 x
    then not false
    else or (elem x x5) (elem x x6)

flatten :: <a> . (t:Tree (a) -> {List (a)|len _v == size t})
flatten = \t . match t with
  Empty -> Nil
  Node x4 x5 x6 -> Cons x4 (append (flatten x5) (flatten x6))

insert :: <a> . (x:a -> (xs:IList (a) -> {IList (a)|ielems _v == (ielems xs) + ([x])}))
insert = \x . \xs . match xs with
  INil -> ICons x INil
  ICons x9 x10 -> if (&&) ((<=) x x9) ((<=) x9 x)
    then xs
    else if (<=) x9 x
      then ICons x9 (insert x x10)
      else ICons x (ICons x9 x10)

insertSort :: <a> . (xs:List (a) -> {IList (a)|ielems _v == elems xs})
insertSort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> insert x3 (insertSort x4)

split :: <a> . (xs:List (a) -> {Pair ({List (a)|abs(len xs - len _v * 2) <= 1}) (List (a))|len fst _v + len snd _v == len xs && (elems fst _v) + (elems snd _v) == elems xs})
split = \xs . match xs with
  Nil -> Pair xs xs
  Cons x7 x8 -> match x8 with
    Nil -> Pair x8 xs
    Cons x15 x16 -> match split x16 with
      Pair x21 x22 -> Pair (Cons x15 x21) (Cons x7 x22)

merge :: <a> . (xs:IList (a) -> (ys:IList (a) -> {IList (a)|ilen _v == ilen xs + ilen ys && ielems _v == (ielems xs) + (ielems ys)}))
merge = \xs . \ys . match ys with
  INil -> xs
  ICons x4 x5 -> match xs with
    INil -> ICons x4 x5
    ICons x14 x15 -> if (<) x14 x4
      then ICons x14 (merge x15 (ICons x4 x5))
      else ICons x4 (merge (ICons x14 x15) x5)

mergeSort :: <a> . (xs:List (a) -> {IList (a)|ilen _v == len xs && ielems _v == elems xs})
mergeSort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> match x4 with
    Nil -> ICons x3 INil
    Cons x17 x18 -> match split xs with
      Pair x24 x25 -> merge (mergeSort x24) (mergeSort x25)

partition :: <a> . (p:a -> (xs:List (a) -> {Pair (List ({a|_v <= p})) (List ({a|_v > p}))|len fst _v + len snd _v == len xs && (elems fst _v) + (elems snd _v) == elems xs}))
partition = \p . \xs . match xs with
  Nil -> Pair Nil Nil
  Cons x7 x8 -> match partition p x8 with
    Pair x19 x20 -> if (<=) x7 p
      then Pair (Cons x7 x19) x20
      else Pair x19 (Cons x7 x20)

pivotAppend :: <a> . (p:a -> (xs:IList ({a|_v <= p}) -> (ys:IList ({a|_v > p}) -> {IList (a)|ilen _v == (ilen xs + ilen ys) + 1 && ielems _v == ((ielems xs) + (ielems ys)) + ([p])})))
pivotAppend = \p . \xs . \ys . match xs with
  INil -> ICons p ys
  ICons x8 x9 -> ICons x8 (pivotAppend p x9 ys)

quickSort :: <a> . (xs:List (a) -> {IList (a)|ilen _v == len xs && ielems _v == elems xs})
quickSort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> match partition x3 x4 with
    Pair x17 x18 -> pivotAppend x3 (quickSort x17) (quickSort x18)

member :: <a> . (x:a -> (t:BST (a) -> {Bool|_v == (x) in (telems t)}))
member = \x . \t . match t with
  Empty -> false
  Node x4 x5 x6 -> if (&&) ((<=) x x4) ((<=) x4 x)
    then true
    else if (<=) x x4
      then member x x5
      else member x x6

insert :: <a> . (x:a -> (t:BST (a) -> {BST (a)|elems _v == (elems t) + ([x])}))
insert = \x . \t . match t with
  Empty -> Node x Empty Empty
  Node x10 x11 x12 -> if (&&) ((<=) x x10) ((<=) x10 x)
    then t
    else if (<=) x10 x
      then Node x10 x11 (insert x x12)
      else Node x10 (insert x x11) x12

insert :: <a> . (x:a -> (t:BST (a) -> {BST (a)|telems _v == (telems t) + ([x])}))
insert = \x . \t . match t with
  Empty -> Node x Empty Empty
  Node x10 x11 x12 -> if (&&) ((<=) x x10) ((<=) x10 x)
    then t
    else if (<=) x10 x
      then Node x10 x11 (insert x x12)
      else Node x10 (insert x x11) x12

toBST :: <a> . (xs:List (a) -> {BST (a)|telems _v == elems xs})
toBST = \xs . match xs with
  Nil -> Empty
  Cons x3 x4 -> insert x3 (toBST x4)

pivotAppend :: <a> . (p:a -> (xs:IList ({a|_v < p}) -> (ys:IList ({a|_v > p}) -> {IList (a)|ilen _v == (ilen xs + ilen ys) + 1 && ielems _v == ((ielems xs) + (ielems ys)) + ([p])})))
pivotAppend = \p . \xs . \ys . match xs with
  INil -> ICons p ys
  ICons x12 x13 -> ICons x12 (pivotAppend p x13 ys)

flatten :: <a> . (t:BST (a) -> {IList (a)|ielems _v == telems t})
flatten = \t . match t with
  Empty -> INil
  Node x4 x5 x6 -> pivotAppend x4 (flatten x5) (flatten x6)

sort :: <a> . (xs:List (a) -> {IList (a)|ielems _v == elems xs})
sort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> flatten (toBST xs)

mergePivot :: <a> . (p:a -> (t1:BST ({a|_v < p}) -> (t2:BST ({a|_v > p}) -> {BST (a)|elems _v == (elems t1) + (elems t2)})))
mergePivot = \p . \t1 . \t2 . match t1 with
  Empty -> t2
  Node x5 x6 x7 -> Node x5 x6 (mergePivot p x7 t2)

delete :: <a> . (t:BST (a) -> (x:a -> {BST (a)|elems _v == (elems t) - ([x])}))
delete = \t . \x . match t with
  Empty -> t
  Node x4 x5 x6 -> if (==) x4 x
    then mergePivot x x5 x6
    else if (<) x4 x
      then Node x4 x5 (delete x6 x)
      else Node x4 (delete x5 x) x6

member :: <a> . (x:a -> (t:Heap (a) -> {Bool|_v == (x) in (elems t)}))
member = \x . \t . match t with
  Empty -> false
  Node x4 x5 x6 -> if (==) x4 x
    then not false
    else or (member x x5) (member x x6)

