qualifier {x < y, x == y}

type Color = {Int | _v == 0 || _v == 1}

black :: {Int | _v == 0}
red   :: {Int | _v == 1}

measure size        :: RBT a -> {Int | _v >= 0}
measure elems       :: RBT a -> Set a
measure isRed       :: RBT a -> Bool 
measure blackHeight :: RBT a -> Int

data RBT a decreases size where
    Empty :: {RBT a | size _v == 0 && 
              elems _v == [] && 
              !isRed _v &&                 -- nils (empty nodes) must be black
              blackHeight _v == 0}         -- black-height of nils is 0
    Node  :: x: a -> 
             color: Color -> 
             left:  {RBT {a | _v < x} | color == 1 ==> !isRed _v} ->                 -- left keys are less than this key; a red node must have black children
             right: {RBT {a | _v > x} | (color == 1 ==> !isRed _v) &&                -- right keys are greater than this key; a red node must have black children; 
                                        (blackHeight _v == blackHeight left)} ->     -- blackHeight the same as of left
             {RBT a | size _v == size left + size right + 1 && 
                      elems _v == elems left + elems right + [x] && 
                      (!isRed _v ==> (blackHeight _v == blackHeight left + 1)) &&    -- if black ==> black-height is black-height of sub + 1
                      (isRed _v ==> (blackHeight _v == blackHeight left)) &&         -- if red   ==> black-height is black-height of sub
                      (isRed _v <==> color == 1)}                   

--======================================================================
-- Takes two RBTs split around a pivot point, and returns a new RBT
-- that contains the pivot point as well as the elements from both
-- input RBTs.
--
-- Using this function to synthesize insert is a bit too much of a cheat,
-- since this function is really no simpler than insert.  In the RBT'
-- example, this function is relaxed, so that it actually matches
-- the Leon implementation.
--======================================================================
balance :: x: a -> c: Color -> l: RBT {a | _v < x} -> r: RBT {a | _v > x} -> {RBT a | elems _v == elems l + elems r + [x]}

--======================================================================
-- insert x t =
--   match t with
--     Empty -> Node x red Empty Empty
--     Node e c l r -> if x == e
--                     then t
--                     else if e < x
--                          then balance e c l (insert x r)
--                          else balance e c (insert x l) r
--
-- args used: -e -m=1 -a=2
-- time: 1m38s (on aleks's X1 Carbon)
--======================================================================

insert :: x: a -> t: RBT a -> {RBT a | elems _v == elems t + [x]}
insert = ??
