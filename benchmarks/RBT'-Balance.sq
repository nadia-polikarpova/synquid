--==========================================================================================
-- running the whole file should take ~1m30s
--
-- This doesn't look killer, but it won't hurt. 
--
-- Syntesizing 'balance' at once would require at least 4 matches, so not sure whether that
-- would scale (not tried it though).
--==========================================================================================

qualifier {x == y}

type Color = {Int | _v == 0 || _v == 1}

black :: {Int | _v == 0}
red   :: {Int | _v == 1}

measure size           :: RBT' a -> {Int | _v >= 0}
measure elems          :: RBT' a -> Set a
measure isRed          :: RBT' a -> Bool 
measure blackHeight    :: RBT' a -> Int
measure redsHaveBlacks :: RBT' a -> Bool

--==========================================================================================
-- RBT' is like real RBT just without the "Red node has black children" constraint. Instead
-- of encoding it as an invariant, that particular constraint is encoded as a measure, so
-- that only select functions can decide to enforce it in their postconditions.
--==========================================================================================
data RBT' a decreases size where
    Empty :: {RBT' a | size _v == 0      && 
                       elems _v == []    && 
                       !isRed _v         &&         -- nils (empty nodes) must be black
                       redsHaveBlacks _v &&         -- neither red nor has any children, thus, true
                       blackHeight _v == 0}         -- black-height of nils is 0 (could be 1, doesn't matter)
    Node  :: x: a -> 
             color: Color -> 
             left:  RBT' {a | _v < x} ->                                              -- left keys are less than this key
             right: {RBT' {a | _v > x} | (blackHeight _v == blackHeight left)} ->     -- right keys are greater than this key; blackHeight the same as of left
             {RBT' a | size _v == size left + size right + 1 && 
                       elems _v == elems left + elems right + [x] && 
                       (!isRed _v ==> (blackHeight _v == blackHeight left + 1)) &&    -- if black ==> black-height is black-height of sub + 1
                       (isRed  _v ==> (blackHeight _v == blackHeight left)) &&        -- if red   ==> black-height is black-height of sub
                       (!isRed _v ==> (redsHaveBlacks _v <==> (redsHaveBlacks left && redsHaveBlacks right))) &&                           
                       (isRed  _v ==> (redsHaveBlacks _v <==> (!isRed left && !isRed left && redsHaveBlacks left && redsHaveBlacks right))) &&
                       (isRed _v <==> color == 1)}                   

--==========================================================================================
-- First balancing case, as depicted below:
--
--       B                R
--      / \             /   \
--     R  pr           B     B
--    / \     --->    / \   / \
--   R  nr          cl  cr nr  pr 
--  / \
-- cl cr
--
-- Hopefully it is possible to infer all of the preconditions specified below from within 
-- the 'balance' method, once the input tree to 'balance' is decomposed. 
--
-- Solution: 
--
--    balanceI pk nk ck cl cr nr pr = Node nk red (Node ck black cl cr) (Node pk black nr pr)
-- 
-- args used       : -e -m=0 -a=2
-- components used : none
-- time            : 27s (on aleks's X1 Carbon)
--==========================================================================================
balanceI :: pk: a ->                
            nk: {a | _v < pk} ->
            ck: {a | _v < nk} ->
            cl: {RBT' {a | _v < ck}            | !isRed _v && redsHaveBlacks _v} ->
            cr: {RBT' {a | _v > ck && _v < nk} | !isRed _v && blackHeight _v == blackHeight cl && redsHaveBlacks _v} ->
            nr: {RBT' {a | _v > nk && _v < pk} | !isRed _v && blackHeight _v == blackHeight cr && redsHaveBlacks _v} -> 
            pr: {RBT' {a | _v > pk}            | blackHeight _v == blackHeight nr && redsHaveBlacks _v} ->
            {RBT' a | elems _v == [pk] + [nk] + [ck] + elems cl + elems cr + elems nr + elems pr && blackHeight _v == blackHeight pr + 1 && redsHaveBlacks _v}
balanceI = ??

--==========================================================================================
-- Second balancing case, as depicted below:
--
--       B                R
--      / \             /   \
--     R  pr           B     B
--    / \     --->    / \   / \
--   nl  R           nl cl cr pr
--      / \
--     cl cr
--
-- Hopefully it is possible to infer all of the preconditions specified below from within 
-- the 'balance' method, once the input tree to 'balance' is decomposed. 
--
-- Solution: 
--
--    balanceII pk nk nl ck cl cr pr = Node ck red (Node nk black nl cl) (Node pk black cr pr)
-- 
-- args used       : -e -m=0 -a=2
-- components used : none
-- time            : 28s (on aleks's X1 Carbon)
--==========================================================================================
balanceII :: pk: a ->                
             nk: {a | _v < pk} ->
             nl: {RBT' {a | _v < nk} | !isRed _v && redsHaveBlacks _v} -> 
             ck: {a | _v > nk && _v < pk} ->
             cl: {RBT' {a | _v < ck && _v > nk} | !isRed _v && blackHeight _v == blackHeight nl && redsHaveBlacks _v} ->
             cr: {RBT' {a | _v > ck && _v < pk} | !isRed _v && blackHeight _v == blackHeight cl && redsHaveBlacks _v} ->
             pr: {RBT' {a | _v > pk}            | blackHeight _v == blackHeight cr && redsHaveBlacks _v} ->
             {RBT' a | elems _v == [pk] + [nk] + [ck] + elems nl + elems cl + elems cr + elems pr && blackHeight _v == blackHeight pr + 1 && redsHaveBlacks _v}
balanceII = ??

--==========================================================================================
-- Third balancing case, as depicted below:
--
--       B                    R
--      / \                 /   \
--     pl  R               B     B
--        / \     --->    / \   / \
--       R   nr          pl cl cr nr
--      / \
--     cl cr
--
-- Hopefully it is possible to infer all of the preconditions specified below from within 
-- the 'balance' method, once the input tree to 'balance' is decomposed. 
--
-- Solution: 
--
--    balanceIII pk pl nk ck cl cr nr = Node ck red (Node pk black pl cl) (Node nk black cr nr)
-- 
-- args used       : -e -m=0 -a=2
-- components used : none
-- time            : 36s (on aleks's X1 Carbon)
--==========================================================================================
balanceIII :: pk: a ->                
              pl: {RBT' {a | _v < pk} | redsHaveBlacks _v} ->
              nk: {a | _v > pk} ->
              ck: {a | _v < nk && _v > pk} ->
              cl: {RBT' {a | _v < ck && _v > pk} | !isRed _v && blackHeight _v == blackHeight pl && redsHaveBlacks _v} ->
              cr: {RBT' {a | _v > ck && _v < nk} | !isRed _v && blackHeight _v == blackHeight cl && redsHaveBlacks _v} ->
              nr: {RBT' {a | _v > nk}            | !isRed _v && blackHeight _v == blackHeight cr && redsHaveBlacks _v} -> 
              {RBT' a | elems _v == [pk] + [nk] + [ck] + elems pl + elems cl + elems cr + elems nr && blackHeight _v == blackHeight pl + 1 && redsHaveBlacks _v} 
balanceIII = ??

--==========================================================================================
-- Fourth balancing case, as depicted below:
--
--       B                    R
--      / \                 /   \
--     pl  R               B     B
--        / \     --->    / \   / \
--       nl  R           pl nl cl cr
--          / \
--         cl cr
--
-- Hopefully it is possible to infer all of the preconditions specified below from within 
-- the 'balance' method, once the input tree to 'balance' is decomposed. 
--
-- Solution: 
--
--    balanceIV pk pl nk nl ck cl cr = Node nk red (Node pk black pl nl) (Node ck black cl cr)
-- 
-- args used       : -e -m=0 -a=2
-- components used : none
-- time            : 1m3s
--==========================================================================================
balanceIV :: pk: a ->                
             pl: {RBT' {a | _v < pk} | redsHaveBlacks _v} ->
             nk: {a | _v > pk} ->
             nl: {RBT' {a | _v < nk && _v > pk} | !isRed _v && blackHeight _v == blackHeight pl && redsHaveBlacks _v} -> 
             ck: {a | _v > nk} ->
             cl: {RBT' {a | _v < ck && _v > nk} | !isRed _v && blackHeight _v == blackHeight nl && redsHaveBlacks _v} ->
             cr: {RBT' {a | _v > ck}            | !isRed _v && blackHeight _v == blackHeight cl && redsHaveBlacks _v} ->
             {RBT' a | elems _v == [pk] + [nk] + [ck] + elems pl + elems nl + elems cl + elems cr && blackHeight _v == blackHeight pl + 1 && redsHaveBlacks _v} 
balanceIV = ??
