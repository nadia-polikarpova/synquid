max2 :: (x:Int -> (y:Int -> {Int|_v >= x && _v >= y}))
max2 = \x . \y . if (>=) x y
  then x
  else y
(Size: 11)
(Spec size: 7)
(#measures: 0)
(#components: 0)

max3 :: (x:Int -> (y:Int -> (z:Int -> {Int|(_v >= x && _v >= y) && _v >= z})))
max3 = \x . \y . \z . if (&&) ((>=) x y) ((>=) x z)
  then x
  else if (>=) y z
    then y
    else z
(Size: 27)
(Spec size: 11)
(#measures: 0)
(#components: 0)

max4 :: (w:Int -> (x:Int -> (y:Int -> (z:Int -> {Int|((_v >= w && _v >= x) && _v >= y) && _v >= z}))))
max4 = \w . \x . \y . \z . if (&&) ((>=) w x) ((&&) ((>=) w y) ((>=) w z))
  then w
  else if (&&) ((>=) x y) ((>=) x z)
    then x
    else if (>=) y z
      then y
      else z
(Size: 51)
(Spec size: 15)
(#measures: 0)
(#components: 0)

max5 :: (v:Int -> (w:Int -> (x:Int -> (y:Int -> (z:Int -> {Int|(((_v >= v && _v >= w) && _v >= x) && _v >= y) && _v >= z})))))
max5 = \v . \w . \x . \y . \z . if (&&) ((>=) v w) ((&&) ((>=) v x) ((&&) ((>=) v y) ((>=) v z)))
  then v
  else if (&&) ((>=) w x) ((&&) ((>=) w y) ((>=) w z))
    then w
    else if (&&) ((>=) x y) ((>=) x z)
      then x
      else if (>=) y z
        then y
        else z
(Size: 83)
(Spec size: 19)
(#measures: 0)
(#components: 0)

add :: (x:{Int|_v >= 0} -> (y:{Int|_v >= 0} -> {Int|_v == x + y}))
add = \x . \y . if (>=) 0 y
  then x
  else if (>=) 0 x
    then y
    else inc (add x (dec y))
(Size: 26)
(Spec size: 11)
(#measures: 0)
(#components: 3)

null :: <a> . (xs:List (a) -> {Bool|_v == (len xs == 0)})
null = \xs . match xs with
  Nil -> true
  Cons x3 x4 -> false
(Size: 6)
(Spec size: 6)
(#measures: 1)
(#components: 2)

elem :: <a> . (x:a -> (xs:List (a) -> {Bool|_v == (x) in (elems xs)}))
elem = \x . \xs . match xs with
  Nil -> false
  Cons x3 x4 -> if (==) x3 x
    then true
    else elem x x4
(Size: 18)
(Spec size: 6)
(#measures: 2)
(#components: 2)

stutter :: <a> . (xs:List (a) -> {List (a)|len _v == 2 * len xs})
stutter = \xs . match xs with
  Nil -> xs
  Cons x3 x4 -> Cons x3 (Cons x3 (stutter x4))
(Size: 16)
(Spec size: 7)
(#measures: 1)
(#components: 0)

replicate :: <a> . (n:{Int|_v >= 0} -> (x:a -> {List (a)|len _v == n}))
replicate = \n . \x . if (>=) 0 n
  then Nil
  else Cons x (replicate (dec n) x)
(Size: 21)
(Spec size: 7)
(#measures: 1)
(#components: 3)

append :: <a> . (xs:List (a) -> (ys:List (a) -> {List (a)|len _v == len xs + len ys}))
append = \xs . \ys . match ys with
  Nil -> xs
  Cons x4 x5 -> Cons x4 (append xs x5)
(Size: 15)
(Spec size: 8)
(#measures: 1)
(#components: 0)

concat :: <a> . (xss:ListOfLists (a) -> {List (a)|len _v == sumLen xss})
concat = \xss . match xss with
  Nil2 -> Nil
  Cons2 x3 x4 -> append x3 (concat x4)
(Size: 12)
(Spec size: 5)
(#measures: 3)
(#components: 1)

take :: <a> . (n:{Int|_v >= 0} -> (xs:{List (a)|len _v >= n} -> {List (a)|len _v == n}))
take = \n . \xs . match xs with
  Nil -> xs
  Cons x4 x5 -> if (>=) 0 n
    then Nil
    else Cons x4 (take (dec n) x5)
(Size: 24)
(Spec size: 11)
(#measures: 1)
(#components: 2)

drop :: <a> . (n:{Int|_v >= 0} -> (xs:{List (a)|len _v >= n} -> {List (a)|len _v == len xs - n}))
drop = \n . \xs . if (<=) n 0
  then xs
  else match xs with
    Nil -> error
    Cons x4 x5 -> drop (dec n) x5
(Size: 20)
(Spec size: 14)
(#measures: 1)
(#components: 2)

delete :: <a> . (x:a -> (xs:List (a) -> {List (a)|elems _v == (elems xs) - ([x])}))
delete = \x . \xs . match xs with
  Nil -> xs
  Cons x3 x4 -> if (==) x3 x
    then delete x x4
    else Cons x3 (delete x x4)
(Size: 26)
(Spec size: 8)
(#measures: 2)
(#components: 0)

map :: <b> . <a> . (f:(_:a -> b) -> (xs:List (a) -> {List (b)|len _v == len xs}))
map = \f . \xs . match xs with
  Nil -> Nil
  Cons x3 x4 -> Cons (f x3) (map f0 x4)
  where
    f0 = \x14 . f x14
(Size: 22)
(Spec size: 5)
(#measures: 1)
(#components: 0)

zipWith :: <c> . <b> . <a> . (f:(_:a -> (_:b -> c)) -> (xs:List (a) -> (ys:{List (b)|len _v == len xs} -> {List (c)|len _v == len xs})))
zipWith = \f . \xs . \ys . match xs with
  Nil -> Nil
  Cons x4 x5 -> match ys with
    Nil -> error
    Cons x8 x9 -> Cons (f x4 x8) (zipWith f0 x5 x9)
  where
    f0 = \x22 . \x23 . f x22 x23
(Size: 33)
(Spec size: 10)
(#measures: 1)
(#components: 0)

zip :: <b> . <a> . (xs:List (a) -> (ys:{List (b)|len _v == len xs} -> {List (Pair (a) (b))|len _v == len xs}))
zip = \xs . \ys . match xs with
  Nil -> Nil
  Cons x4 x5 -> match ys with
    Nil -> error
    Cons x8 x9 -> Cons (Pair x4 x8) (zip x5 x9)
(Size: 22)
(Spec size: 10)
(#measures: 3)
(#components: 0)

toNat :: (xs:List (Int) -> {List ({Int|_v >= 0})|len _v == len xs})
toNat = \xs . map f0 xs
  where
    f0 = \x4 . if (>=) x4 0
        then x4
        else neg x4
(Size: 19)
(Spec size: 8)
(#measures: 1)
(#components: 2)

product :: <b> . <a> . (la:List (a) -> (lb:List (b) -> {List (Pair (a) (b))|len _v == len la * len lb}))
product = \la . \lb . match la with
  Nil -> Nil
  Cons x4 x5 -> append (map f0 lb) (product x5 lb)
  where
    f0 = \x13 . Pair x4 x13
(Size: 26)
(Spec size: 8)
(#measures: 3)
(#components: 2)

insert :: <a> . (x:a -> (xs:UList (a) -> {UList (a)|uelems _v == (uelems xs) + ([x])}))
insert = \x . \xs . match xs with
  UNil -> UCons x UNil
  UCons x7 x8 -> if (==) x7 x
    then xs
    else UCons x7 (insert x x8)
(Size: 26)
(Spec size: 8)
(#measures: 2)
(#components: 0)

delete :: <a> . (x:a -> (xs:UList (a) -> {UList (a)|uelems _v == (uelems xs) - ([x])}))
delete = \x . \xs . match xs with
  UNil -> xs
  UCons x3 x4 -> if (==) x3 x
    then x4
    else UCons x3 (delete x x4)
(Size: 22)
(Spec size: 8)
(#measures: 2)
(#components: 0)

elem :: <a> . (x:a -> (xs:UList (a) -> {Bool|_v == (x) in (uelems xs)}))
elem = \x . \xs . match xs with
  UNil -> false
  UCons x3 x4 -> if (==) x3 x
    then true
    else elem x x4
(Size: 18)
(Spec size: 6)
(#measures: 4)
(#components: 2)

strengthen :: <a> . (x:a -> (xs:{UList (a)|!(x) in (uelems _v)} -> {UList ({a|_v /= x})|uelems _v == uelems xs && ulen _v == ulen xs}))
strengthen = \x . \xs . match xs with
  UNil -> UNil
  UCons x3 x4 -> UCons x3 (strengthen x x4)
(Size: 15)
(Spec size: 19)
(#measures: 4)
(#components: 3)

nub' :: <a> . (xs:List (a) -> (acc:UList (a) -> {UList (a)|uelems _v == (uelems acc) + (elems xs)}))
nub' = \xs . \acc . match xs with
  Nil -> acc
  Cons x3 x4 -> if elem x3 acc
    then nub' x4 acc
    else nub' x4 (UCons x3 (strengthen x3 acc))
(Size: 30)
(Spec size: 8)
(#measures: 4)
(#components: 4)

compress :: <a> . (xs:List (a) -> {CList (a)|celems _v == elems xs})
compress = \xs . match xs with
  Nil -> CNil
  Cons x3 x4 -> match compress x4 with
    CNil -> CCons x3 CNil
    CCons x13 x14 -> if (==) x3 x13
      then CCons x13 x14
      else CCons x3 (CCons x13 x14)
(Size: 34)
(Spec size: 5)
(#measures: 5)
(#components: 0)

insert :: <a> . (x:a -> (xs:IList (a) -> {IList (a)|ielems _v == (ielems xs) + ([x])}))
insert = \x . \xs . match xs with
  INil -> ICons x INil
  ICons x7 x8 -> if (&&) ((<=) x x7) ((<=) x7 x)
    then xs
    else if (<=) x7 x
      then ICons x7 (insert x x8)
      else ICons x (ICons x7 x8)
(Size: 49)
(Spec size: 8)
(#measures: 2)
(#components: 0)

insertSort :: <a> . (xs:List (a) -> {IList (a)|ielems _v == elems xs})
insertSort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> insert x3 (insertSort x4)
(Size: 12)
(Spec size: 5)
(#measures: 4)
(#components: 1)

insert :: <a> . (x:a -> (xs:IList (a) -> {IList (a)|ielems _v == (ielems xs) + ([x])}))
insert = \x . \xs . match xs with
  INil -> ICons x INil
  ICons x7 x8 -> if (&&) ((<=) x x7) ((<=) x7 x)
    then xs
    else if (<=) x7 x
      then ICons x7 (insert x x8)
      else ICons x (ICons x7 x8)
(Size: 49)
(Spec size: 8)
(#measures: 2)
(#components: 0)

delete :: <a> . (x:a -> (xs:IList (a) -> {IList (a)|ielems _v == (ielems xs) - ([x])}))
delete = \x . \xs . match xs with
  INil -> xs
  ICons x3 x4 -> if (&&) ((<=) x x3) ((<=) x3 x)
    then x4
    else if (<=) x x3
      then xs
      else ICons x3 (delete x x4)
(Size: 37)
(Spec size: 8)
(#measures: 2)
(#components: 0)

split :: <a> . (xs:List (a) -> {Pair ({List (a)|abs(len xs - len _v * 2) <= 1}) (List (a))|len fst _v + len snd _v == len xs && (elems fst _v) + (elems snd _v) == elems xs})
split = \xs . match xs with
  Nil -> Pair xs xs
  Cons x7 x8 -> match x8 with
    Nil -> Pair x8 xs
    Cons x15 x16 -> match split x16 with
      Pair x21 x22 -> Pair (Cons x15 x21) (Cons x7 x22)
(Size: 33)
(Spec size: 31)
(#measures: 4)
(#components: 0)

merge :: <a> . (xs:IList (a) -> (ys:IList (a) -> {IList (a)|ilen _v == ilen xs + ilen ys && ielems _v == (ielems xs) + (ielems ys)}))
merge = \xs . \ys . match ys with
  INil -> xs
  ICons x4 x5 -> match xs with
    INil -> ICons x4 x5
    ICons x12 x13 -> if (<) x12 x4
      then ICons x12 (merge x13 (ICons x4 x5))
      else ICons x4 (merge (ICons x12 x13) x5)
(Size: 45)
(Spec size: 17)
(#measures: 2)
(#components: 0)

mergeSort :: <a> . (xs:List (a) -> {IList (a)|ilen _v == len xs && ielems _v == elems xs})
mergeSort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> match x4 with
    Nil -> ICons x3 INil
    Cons x11 x12 -> match split xs with
      Pair x17 x18 -> merge (mergeSort x17) (mergeSort x18)
(Size: 25)
(Spec size: 11)
(#measures: 6)
(#components: 2)

partition :: <a> . (p:a -> (xs:List (a) -> {Pair (List ({a|_v <= p})) (List ({a|_v > p}))|len fst _v + len snd _v == len xs && (elems fst _v) + (elems snd _v) == elems xs}))
partition = \p . \xs . match xs with
  Nil -> Pair Nil Nil
  Cons x7 x8 -> match partition p x8 with
    Pair x15 x16 -> if (<=) x7 p
      then Pair (Cons x7 x15) x16
      else Pair x15 (Cons x7 x16)
(Size: 40)
(Spec size: 27)
(#measures: 4)
(#components: 0)

pivotAppend :: <a> . (p:a -> (xs:IList ({a|_v <= p}) -> (ys:IList ({a|_v > p}) -> {IList (a)|ilen _v == (ilen xs + ilen ys) + 1 && ielems _v == ((ielems xs) + (ielems ys)) + ([p])})))
pivotAppend = \p . \xs . \ys . match xs with
  INil -> ICons p ys
  ICons x8 x9 -> ICons x8 (pivotAppend p x9 ys)
(Size: 22)
(Spec size: 28)
(#measures: 2)
(#components: 0)

quickSort :: <a> . (xs:List (a) -> {IList (a)|ilen _v == len xs && ielems _v == elems xs})
quickSort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> match partition x3 x4 with
    Pair x11 x12 -> pivotAppend x3 (quickSort x11) (quickSort x12)
(Size: 22)
(Spec size: 11)
(#measures: 6)
(#components: 2)

elem :: <a> . (x:a -> (t:Tree (a) -> {Bool|_v == (x) in (telems t)}))
elem = \x . \t . match t with
  Empty -> false
  Node x4 x5 x6 -> if (==) x4 x
    then not false
    else or (elem x x5) (elem x x6)
(Size: 28)
(Spec size: 6)
(#measures: 2)
(#components: 3)

flatten :: <a> . (t:Tree (a) -> {List (a)|len _v == size t})
flatten = \t . match t with
  Empty -> Nil
  Node x4 x5 x6 -> Cons x4 (append (flatten x5) (flatten x6))
(Size: 18)
(Spec size: 5)
(#measures: 2)
(#components: 1)

hbal :: <a> . (h:{Int|_v >= 0} -> {Tree (a)|height _v == h})
hbal = \h . if (==) h 0
  then Empty
  else Node (hbal (dec h)) (hbal (dec h))
(Size: 22)
(Spec size: 7)
(#measures: 2)
(#components: 2)

member :: <a> . (x:a -> (t:BST (a) -> {Bool|_v == (x) in (telems t)}))
member = \x . \t . match t with
  Empty -> false
  Node x4 x5 x6 -> if (&&) ((<=) x x4) ((<=) x4 x)
    then true
    else if (<=) x x4
      then member x x5
      else member x x6
(Size: 37)
(Spec size: 6)
(#measures: 2)
(#components: 2)

insert :: <a> . (x:a -> (t:BST (a) -> {BST (a)|elems _v == (elems t) + ([x])}))
insert = \x . \t . match t with
  Empty -> Node x Empty Empty
  Node x10 x11 x12 -> if (&&) ((<=) x x10) ((<=) x10 x)
    then t
    else if (<=) x10 x
      then Node x10 x11 (insert x x12)
      else Node x10 (insert x x11) x12
(Size: 55)
(Spec size: 8)
(#measures: 2)
(#components: 0)

mergePivot :: <a> . (p:a -> (t1:BST ({a|_v < p}) -> (t2:BST ({a|_v > p}) -> {BST (a)|elems _v == (elems t1) + (elems t2)})))
mergePivot = \p . \t1 . \t2 . match t1 with
  Empty -> t2
  Node x5 x6 x7 -> Node x5 x6 (mergePivot p x7 t2)
(Size: 20)
(Spec size: 14)
(#measures: 2)
(#components: 0)

delete :: <a> . (t:BST (a) -> (x:a -> {BST (a)|elems _v == (elems t) - ([x])}))
delete = \t . \x . match t with
  Empty -> t
  Node x4 x5 x6 -> if (==) x4 x
    then mergePivot x x5 x6
    else if (<) x4 x
      then Node x4 x5 (delete x6 x)
      else Node x4 (delete x5 x) x6
(Size: 47)
(Spec size: 8)
(#measures: 2)
(#components: 1)

insert :: <a> . (x:a -> (t:BST (a) -> {BST (a)|telems _v == (telems t) + ([x])}))
insert = \x . \t . match t with
  Empty -> Node x Empty Empty
  Node x10 x11 x12 -> if (&&) ((<=) x x10) ((<=) x10 x)
    then t
    else if (<=) x10 x
      then Node x10 x11 (insert x x12)
      else Node x10 (insert x x11) x12
(Size: 55)
(Spec size: 8)
(#measures: 6)
(#components: 0)

toBST :: <a> . (xs:List (a) -> {BST (a)|telems _v == elems xs})
toBST = \xs . match xs with
  Nil -> Empty
  Cons x3 x4 -> insert x3 (toBST x4)
(Size: 12)
(Spec size: 5)
(#measures: 6)
(#components: 1)

pivotAppend :: <a> . (p:a -> (xs:IList ({a|_v < p}) -> (ys:IList ({a|_v > p}) -> {IList (a)|ilen _v == (ilen xs + ilen ys) + 1 && ielems _v == ((ielems xs) + (ielems ys)) + ([p])})))
pivotAppend = \p . \xs . \ys . match xs with
  INil -> ICons p ys
  ICons x8 x9 -> ICons x8 (pivotAppend p x9 ys)
(Size: 22)
(Spec size: 28)
(#measures: 6)
(#components: 2)

flatten :: <a> . (t:BST (a) -> {IList (a)|ielems _v == telems t})
flatten = \t . match t with
  Empty -> INil
  Node x4 x5 x6 -> pivotAppend x4 (flatten x5) (flatten x6)
(Size: 16)
(Spec size: 5)
(#measures: 6)
(#components: 3)

sort :: <a> . (xs:List (a) -> {IList (a)|ielems _v == elems xs})
sort = \xs . match xs with
  Nil -> INil
  Cons x3 x4 -> flatten (toBST xs)
(Size: 10)
(Spec size: 5)
(#measures: 6)
(#components: 4)

member :: <a> . (x:a -> (t:Heap (a) -> {Bool|_v == (x) in (elems t)}))
member = \x . \t . match t with
  Empty -> false
  Node x4 x5 x6 -> if (==) x4 x
    then not false
    else or (member x x5) (member x x6)
(Size: 28)
(Spec size: 6)
(#measures: 2)
(#components: 3)

tripleton :: <a> . (x:a -> (y:a -> (z:a -> {Heap (a)|elems _v == [x, y, z]})))
tripleton = \x . \y . \z . if (&&) ((==) z x) ((==) z y)
  then Node x Empty Empty
  else if (&&) ((==) z x) ((<) y z)
    then Node y Empty (Node z Empty Empty)
    else if (&&) ((==) z y) ((<) x y)
      then Node x Empty (Node y Empty Empty)
      else if (&&) ((==) z y) ((<) z x)
        then Node z Empty (Node x Empty Empty)
        else if (&&) ((==) y x) ((<) y z)
          then Node y Empty (Node z Empty Empty)
          else if (&&) ((==) z x) ((<) x y)
            then Node x Empty (Node y Empty Empty)
            else if (&&) ((==) y x) ((<) z x)
              then Node z Empty (Node x Empty Empty)
              else if (&&) ((<) y x) ((<) y z)
                then Node y (Node z Empty Empty) (Node x Empty Empty)
                else if (&&) ((<) z x) ((<) z y)
                  then Node z (Node y Empty Empty) (Node x Empty Empty)
                  else Node x (Node y Empty Empty) (Node z Empty Empty)
(Size: 271)
(Spec size: 7)
(#measures: 2)
(#components: 0)

transform :: (x:AST -> {PAST|result2 _v == result x})
transform = \x . match x with
  Zero -> IntNode zero
  One -> IntNode one
  Two -> IntNode two
  PlusNode x9 x10 -> OpNode zero (transform x10) (transform x9)
  MinusNode x23 x24 -> OpNode one (transform x23) (transform x24)
  ProductNode x37 x38 -> OpNode two (transform x37) (transform x38)
(Size: 46)
(Spec size: 5)
(#measures: 4)
(#components: 3)

transform :: (x:AST -> {PAST|result2 _v == result x && elems2 _v == elems x})
transform = \x . match x with
  Zero -> IntNode zero
  One -> IntNode one
  Two -> IntNode two
  Var x8 -> VarNode x8
  PlusNode x13 x14 -> OpNode zero (transform x13) (transform x14)
  MinusNode x27 x28 -> OpNode one (transform x27) (transform x28)
  ProductNode x41 x42 -> OpNode two (transform x41) (transform x42)
(Size: 49)
(Spec size: 11)
(#measures: 6)
(#components: 3)

max :: <P :: Int -> Bool> . (x:{Int|P _v} -> (y:{Int|P _v} -> {Int|(P _v && _v >= x) && _v >= y}))
max = \x . \y . if (>=) x y
  then x
  else y
(Size: 11)
(Spec size: 14)
(#measures: 0)
(#components: 0)

snoc :: <a> . <P :: a -> a -> Bool> . (x:a -> (xs:List ({a|P _v x}) <P _0 _1> -> {List (a) <P _0 _1>|len _v == len xs + 1}))
snoc = \x . \xs . match xs with
  Nil -> Cons x Nil
  Cons x7 x8 -> Cons x7 (snoc x x8)
(Size: 19)
(Spec size: 16)
(#measures: 2)
(#components: 0)

reverse :: <a> . <P :: a -> a -> Bool> . (xs:List (a) <P _0 _1> -> {List (a) <P _1 _0>|len _v == len xs})
reverse = \xs . match xs with
  Nil -> Nil
  Cons x3 x4 -> snoc x3 (reverse x4)
(Size: 12)
(Spec size: 11)
(#measures: 2)
(#components: 1)

foldr :: <b> . <a> . <P :: List (a) -> b -> Bool> . (f:(xs:List (a) -> (x:a -> (acc:{b|P xs _v} -> {b|P (Cons x xs) _v}))) -> (seed:{b|P (Nil) _v} -> (ys:List (a) -> {b|P ys _v})))
foldr = \f . \seed . \ys . match ys with
  Nil -> seed
  Cons x3 x4 -> f x4 x3 (foldr f0 seed x4)
  where
    f0 = \x15 . \x16 . \x17 . f x15 x16 x17
(Size: 32)
(Spec size: 14)
(#measures: 2)
(#components: 2)

length :: <a> . (zs:List (a) -> {Int|_v == len zs})
length = \zs . foldr f0 zero zs
  where
    f0 = \x5 . \x6 . \x7 . inc x7
(Size: 17)
(Spec size: 4)
(#measures: 2)
(#components: 3)

append :: <a> . (xs:List (a) -> (ys:List (a) -> {List (a)|len _v == len xs + len ys}))
append = \xs . \ys . foldr f0 xs ys
  where
    f0 = \x6 . \x7 . \x8 . Cons x7 x8
(Size: 20)
(Spec size: 8)
(#measures: 2)
(#components: 4)

insert :: <a> . (x:a -> (xs:List (a) <_0 <= _1> -> {List (a) <_0 <= _1>|elems _v == (elems xs) + ([x])}))
insert = \x . \xs . match xs with
  Nil -> Cons x Nil
  Cons x7 x8 -> if (&&) ((<=) x x7) ((<=) x7 x)
    then xs
    else if (<=) x7 x
      then Cons x7 (insert x x8)
      else Cons x (Cons x7 x8)
(Size: 49)
(Spec size: 14)
(#measures: 2)
(#components: 0)

singleton :: <a> . (x:a -> {RBT (a) <_0 == 0>|elems _v == [x] && blackHeight _v == 0})
singleton = \x . Node x red (Empty black) (Empty black)
(Size: 14)
(Spec size: 13)
(#measures: 3)
(#components: 2)

dupleton :: <a> . (x:a -> (y:a -> {RBT (a) <True>|elems _v == [x, y]}))
dupleton = \x . \y . if (==) y x
  then singleton x
  else if (<) y x
    then Node y black (Empty black) (singleton x)
    else Node y black (singleton x) (Empty black)
(Size: 43)
(Spec size: 6)
(#measures: 3)
(#components: 3)

tripleton :: <a> . (x:a -> (y:a -> (z:a -> {RBT (a) <True>|elems _v == [x, y, z]})))
tripleton = \x . \y . \z . if (&&) ((==) z x) ((==) z y)
  then singleton x
  else if (==) z x
    then dupleton y z
    else if (==) z y
      then dupleton x y
      else if (==) y x
        then dupleton z x
        else if (&&) ((<) y x) ((<) z y)
          then Node y black (singleton z) (singleton x)
          else if (&&) ((<) x y) ((<) y z)
            then Node y black (singleton x) (singleton z)
            else if (&&) ((<) y z) ((<) z x)
              then Node z black (singleton y) (singleton x)
              else if (&&) ((<) x z) ((<) z y)
                then Node z black (singleton x) (singleton y)
                else if (<) y z
                  then Node x black (singleton y) (singleton z)
                  else Node x black (singleton z) (singleton y)
(Size: 193)
(Spec size: 7)
(#measures: 3)
(#components: 4)

balanceL :: <a> . (x:a -> (lx:{a|_v < x} -> (llc:{Int|_v == 0 || _v == 1} -> (ll:RBT ({a|_v < lx}) <_0 == llc> -> (lr:{RBT ({a|lx < _v && _v < x}) <_0 /= llc>|blackHeight _v == blackHeight ll} -> (r:{RBT ({a|x < _v}) <True>|blackHeight _v == blackHeight ll} -> {RBT (a) <_0 == 0>|elems _v == ((([x, lx]) + (elems ll)) + (elems lr)) + (elems r) && blackHeight _v == blackHeight r + 1}))))))
balanceL = \x . \lx . \llc . \ll . \lr . \r . if (==) llc 0
  then match ll with
    Empty x1 -> error
    Node x6 x7 x8 x9 -> Node lx llc (Node x6 black x8 x9) (Node x black lr r)
  else match lr with
    Empty x35 -> error
    Node x40 x41 x42 x43 -> Node x40 x41 (Node lx llc ll x42) (Node x llc x43 r)
(Size: 68)
(Spec size: 65)
(#measures: 3)
(#components: 2)

balanceR :: <a> . (x:a -> (l:RBT ({a|_v < x}) <True> -> (rx:{a|x < _v} -> (rlc:{Int|_v == 0 || _v == 1} -> (rl:{RBT ({a|x < _v && _v < rx}) <_0 == rlc>|blackHeight _v == blackHeight l} -> (rr:{RBT ({a|rx < _v}) <_0 /= rlc>|blackHeight _v == blackHeight l} -> {RBT (a) <_0 == 0>|elems _v == ((([x, rx]) + (elems l)) + (elems rl)) + (elems rr) && blackHeight _v == blackHeight l + 1}))))))
balanceR = \x . \l . \rx . \rlc . \rl . \rr . if (==) rlc 0
  then match rl with
    Empty x1 -> error
    Node x6 x7 x8 x9 -> Node x6 rlc (Node x black l x8) (Node rx black x9 rr)
  else match rr with
    Empty x35 -> error
    Node x40 x41 x42 x43 -> Node rx x41 (Node x rlc l rl) (Node x40 rlc x42 x43)
(Size: 68)
(Spec size: 65)
(#measures: 3)
(#components: 2)

balanceL :: <a> . (x:a -> (l:WeakRBT ({a|_v < x}) -> (r:{RBT ({a|x < _v}) <True>|blackHeight _v == wheight l} -> {RBT (a) <_0 == 0>|elems _v == (([x]) + (welems l)) + (elems r) && blackHeight _v == blackHeight r + 1})))
balanceL = \x . \l . \r . match l with
  WeakRBT x4 x5 x6 x7 -> if (==) x5 0
    then match x6 with
      Empty x9 -> error
      Node x14 x15 x16 x17 -> Node x4 x15 (Node x14 black x16 x17) (Node x black x7 r)
    else match x7 with
      Empty x43 -> error
      Node x48 x49 x50 x51 -> Node x48 x49 (Node x4 x5 x6 x50) (Node x x5 x51 r)
(Size: 67)
(Spec size: 33)
(#measures: 5)
(#components: 2)

balanceR :: <a> . (x:a -> (l:RBT ({a|_v < x}) <True> -> (r:{WeakRBT ({a|x < _v})|wheight _v == blackHeight l} -> {RBT (a) <_0 == 0>|elems _v == (([x]) + (elems l)) + (welems r) && blackHeight _v == blackHeight l + 1})))
balanceR = \x . \l . \r . match r with
  WeakRBT x4 x5 x6 x7 -> if (==) x5 0
    then match x6 with
      Empty x9 -> error
      Node x14 x15 x16 x17 -> Node x14 x15 (Node x black l x16) (Node x4 black x17 x7)
    else match x7 with
      Empty x43 -> error
      Node x48 x49 x50 x51 -> Node x4 x49 (Node x x5 l x6) (Node x48 x5 x50 x51)
(Size: 67)
(Spec size: 33)
(#measures: 5)
(#components: 3)

