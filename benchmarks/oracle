max2 :: (x:Int -> (y:Int -> {Int|_v >= x && _v >= y}))
max2 = \x . \y . if x >= y
  then x
  else y

max3 :: (x:Int -> (y:Int -> (z:Int -> {Int|(_v >= x && _v >= y) && _v >= z})))
max3 = \x . \y . \z . if x >= y && x >= z
  then x
  else if y >= z
    then y
    else z

max4 :: (w:Int -> (x:Int -> (y:Int -> (z:Int -> {Int|((_v >= w && _v >= x) && _v >= y) && _v >= z}))))
max4 = \w . \x . \y . \z . if w >= x && (w >= y && w >= z)
  then w
  else if x >= y && x >= z
    then x
    else if y >= z
      then y
      else z

max5 :: (v:Int -> (w:Int -> (x:Int -> (y:Int -> (z:Int -> {Int|(((_v >= v && _v >= w) && _v >= x) && _v >= y) && _v >= z})))))
max5 = \v . \w . \x . \y . \z . if v >= w && (v >= x && (v >= y && v >= z))
  then v
  else if w >= x && (w >= y && w >= z)
    then w
    else if x >= y && x >= z
      then x
      else if y >= z
        then y
        else z

add :: (x:{Int|_v >= 0} -> (y:{Int|_v >= 0} -> {Int|_v == x + y}))
add = \x . \y . if 0 >= y
  then x
  else if 0 >= x
    then y
    else inc (add x (dec y))

null :: <a> (xs:List (a) -> {Bool|_v == (len xs == 0)})
null = \xs . match xs with
  Nil -> true
  Cons z5 z6 -> false

elem :: <a> (x:a -> (xs:List (a) -> {Bool|_v == (x) in (elems xs)}))
elem = \x . \xs . match xs with
  Nil -> false
  Cons z5 z6 -> if z5 == x
    then true
    else elem x z6

stutter :: <a> (xs:List (a) -> {List (a)|len _v == 2 * len xs})
stutter = \xs . match xs with
  Nil -> xs
  Cons z5 z6 -> Cons z5 (Cons z5 (stutter z6))

replicate :: <a> (n:{Int|_v >= 0} -> (x:a -> {List (a)|len _v == n}))
replicate = \n . \x . if 0 >= n
  then Nil
  else Cons x (replicate (dec n) x)

append :: <a> (xs:List (a) -> (ys:List (a) -> {List (a)|len _v == len xs + len ys}))
append = \xs . \ys . match ys with
  Nil -> xs
  Cons z6 z7 -> Cons z6 (append xs z7)

take :: <a> (n:{Int|_v >= 0} -> (xs:{List (a)|len _v >= n} -> {List (a)|len _v == n}))
take = \n . \xs . match xs with
  Nil -> xs
  Cons z6 z7 -> if 0 >= n
    then Nil
    else Cons z6 (take (dec n) z7)

drop :: <a> (n:{Int|_v >= 0} -> (xs:{List (a)|len _v >= n} -> {List (a)|len _v == len xs - n}))
drop = \n . \xs . if n <= 0
  then xs
  else match xs with
    Nil -> error
    Cons z9 z10 -> drop (dec n) z10

delete :: <a> (x:a -> (xs:List (a) -> {List (a)|elems _v == (elems xs) - ([x])}))
delete = \x . \xs . match xs with
  Nil -> xs
  Cons z5 z6 -> if z5 == x
    then delete x z6
    else Cons z5 (delete x z6)

map :: <b> <a> (f:(_:a -> b) -> (xs:List (a) -> {List (b)|len _v == len xs}))
map = \f . \xs . match xs with
  Nil -> Nil
  Cons z6 z7 -> Cons (f z6) (map (\x34 . f x34) z7)

zipWith :: <c> <b> <a> (f:(_:a -> (_:b -> c)) -> (xs:List (a) -> (ys:{List (b)|len _v == len xs} -> {List (c)|len _v == len xs})))
zipWith = \f . \xs . \ys . match xs with
  Nil -> Nil
  Cons z7 z8 -> match ys with
    Nil -> error
    Cons z13 z14 -> Cons (f z7 z13) (zipWith (\x47 . \x48 . f x47 x48) z8 z14)

toNat :: (xs:List (Int) -> {List ({Int|_v >= 0})|len _v == len xs})
toNat = \xs . map (\x14 . if x14 >= 0
  then x14
  else neg x14) xs

elem :: <a> (x:a -> (t:Tree (a) -> {Bool|_v == (x) in (telems t)}))
elem = \x . \t . match t with
  Empty -> false
  Node z5 z6 z7 -> if z5 == x
    then not false
    else or (elem x z6) (elem x z7)

flatten :: <a> (t:Tree (a) -> {List (a)|len _v == size t})
flatten = \t . match t with
  Empty -> Nil
  Node z7 z8 z9 -> Cons z7 (append (flatten z8) (flatten z9))

insert :: <a> (x:a -> (xs:IList (a) -> {IList (a)|ielems _v == (ielems xs) + ([x])}))
insert = \x . \xs . match xs with
  INil -> ICons x INil
  ICons z15 z16 -> if x <= z15 && z15 <= x
    then xs
    else if z15 <= x
      then ICons z15 (insert x z16)
      else ICons x (ICons z15 z16)

insertSort :: <a> (xs:List (a) -> {IList (a)|ielems _v == elems xs})
insertSort = \xs . match xs with
  Nil -> INil
  Cons z7 z8 -> insert z7 (insertSort z8)

split :: <a> (xs:List (a) -> {Pair ({List (a)|abs(len xs - len _v * 2) <= 1}) (List (a))|len fst _v + len snd _v == len xs && (elems fst _v) + (elems snd _v) == elems xs})
split = \xs . match xs with
  Nil -> Pair xs xs
  Cons z16 z17 -> match z17 with
    Nil -> Pair z17 xs
    Cons z36 z37 -> match split z37 with
      Pair z54 z55 -> Pair (Cons z16 z54) (Cons z36 z55)

merge :: <a> (xs:IList (a) -> (ys:IList (a) -> {IList (a)|ilen _v == ilen xs + ilen ys && ielems _v == (ielems xs) + (ielems ys)}))
merge = \xs . \ys . match ys with
  INil -> xs
  ICons z6 z7 -> match xs with
    INil -> ICons z6 z7
    ICons z20 z21 -> if z20 < z6
      then ICons z20 (merge z21 (ICons z6 z7))
      else ICons z6 (merge (ICons z20 z21) z7)

mergeSort :: <a> (xs:List (a) -> {IList (a)|ilen _v == len xs && ielems _v == elems xs})
mergeSort = \xs . match xs with
  Nil -> INil
  Cons z7 z8 -> match z8 with
    Nil -> ICons z7 INil
    Cons z32 z33 -> match split xs with
      Pair z52 z53 -> merge (mergeSort z52) (mergeSort z53)

partition :: <a> (p:a -> (xs:List (a) -> {Pair (List ({a|_v <= p})) (List ({a|_v > p}))|len fst _v + len snd _v == len xs && (elems fst _v) + (elems snd _v) == elems xs}))
partition = \p . \xs . match xs with
  Nil -> Pair Nil Nil
  Cons z20 z21 -> match partition p z21 with
    Pair z44 z45 -> if z20 <= p
      then Pair (Cons z20 z44) z45
      else Pair z44 (Cons z20 z45)

pivotAppend :: <a> (p:a -> (xs:IList ({a|_v <= p}) -> (ys:IList ({a|_v > p}) -> {IList (a)|ilen _v == (ilen xs + ilen ys) + 1 && ielems _v == ((ielems xs) + (ielems ys)) + ([p])})))
pivotAppend = \p . \xs . \ys . match xs with
  INil -> ICons p ys
  ICons z13 z14 -> ICons z13 (pivotAppend p z14 ys)

quickSort :: <a> (xs:List (a) -> {IList (a)|ilen _v == len xs && ielems _v == elems xs})
quickSort = \xs . match xs with
  Nil -> INil
  Cons z7 z8 -> match partition z7 z8 with
    Pair z34 z35 -> pivotAppend z7 (quickSort z34) (quickSort z35)

