qualifier {x <= y, x >= y, x != y}

measure len :: List a -> {Int | _v >= 0}
measure elems :: List a -> Set a

data List a decreases len where
	Nil :: {List a | len _v == 0 && elems _v == []}
	Cons :: x: a -> xs: List a -> {List a | len _v == len xs + 1 && elems _v == elems xs + [x]}
	
measure ilen :: IList a -> {Int | _v >= 0}
measure ielems :: IList a -> Set a

data IList a decreases ilen where
	INil :: {IList a | ilen _v == 0 && ielems _v == []}
	ICons :: x: a -> xs: IList {a | x < _v} -> {IList a | ilen _v == ilen xs + 1 && ielems _v == ielems xs + [x]}		

measure size :: BST a -> {Int | _v >= 0}
measure telems :: BST a -> Set a

data BST a decreases size where
	Empty :: {BST a | size _v == 0 && telems _v == []}
	Node :: x: a -> l: BST {a | _v < x} -> r: BST {a | x < _v} -> {BST a | size _v == size l + size r + 1 && telems _v == telems l + telems r + [x]}
	
insert :: x: a -> t: BST a -> {BST a | telems _v == telems t + [x]}
insert = ??	
	
toBST :: xs: List a -> {BST a | telems _v == elems xs}
toBST = ??
		
pivotAppend :: p: a -> xs: IList {a | _v < p} -> ys: IList {a | _v > p} -> {IList a | ilen _v == ilen xs + ilen ys + 1 && ielems _v == ielems xs + ielems ys + [p] }	
pivotAppend = ??
	
flatten :: t: BST a -> {IList a | ielems _v == telems t}
flatten = ??

sort :: xs: List a -> {IList a | ielems _v == elems xs}
sort = ??