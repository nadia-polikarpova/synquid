qualifier {x == y}

{- module Authentication -}

-- | Principals
data Principal
  
predicate IsAuth :: Principal -> Bool  

{- module Location -}
  
type Location = Int

measure loc :: Principal -> Location

predicate CanSeeLocation :: Principal -> Principal -> Bool

-- | Policy axioms 
canSeeOwn :: p: Principal -> {Principal | _v == p && CanSeeLocation _v _v}
canSeeNear :: me: Principal -> dude: {Principal | ~(loc _v - loc me) < 5} -> {Principal | _v == me && CanSeeLocation _v dude}

-- | Interface
getLocation :: me: {Principal | IsAuth _v} -> dude: {Principal | CanSeeLocation me _v} -> {Location | loc dude == _v}
isNear :: me: {Principal | IsAuth _v} -> dude: Principal -> {Bool | _v == (~(loc dude - loc me) < 5)} -- Not really a circular dependency, but I don't see how to express otherwise

{- client -}

whereIsDude :: me: {Principal | IsAuth _v} -> dude: Principal -> {Location | loc dude == _v}
whereIsDude = ??


  
