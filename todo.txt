- Vacuousness abduction with explicit match: doesn't care if the case conditions even play a role; both cases can be false (tests case: BST-DeleteMin)
- More principled type substitution and qualifier discovery, translate type variables and datatypes into uninterpreted types
  - Re-enable sort checking in substitute (sometimes wrong in applications, test case: List-Fold-Sort)
  - Use unifySorts for qualifier substitution instead of complies
  - Qualifier discovery should be local (otherwise doesn't work for abstract refinements?)
- Inline functions
- Named arguments for abstract predicates
- Collapse lambda-expansions in aux goals
- Parametrization by non-boolean predicates
- Mutual recursion
- Type classes (for type variables and abstract datatypes)
- Default components
- Solve the keys measure mystery in BST-delete
- Remove subsumed components (0 + x -> x, x + y -> y + x)
- Field measures (and other independent measures): is it possible to split type-checking per conjunct?
- Intersection types (carry multiple environments and type constraint checkers), good example: allPos :: (List Int -> Bool) &&& (List Pos -> {Bool | _v}) &&& ({List Nonpos | len _v > 0} -> {Bool | !_v})

- Irrefutable type errors (like symbol not in scope)
- Prove measure postconditions
- BUG: polymorphic qualifier extraction
- Check that the first constructor is the base case
- When a measure is not mentioned in the goal spec, remove it from the components?

Security:
- Make use of abstract predicates:
  - Simple way: when the goal type contains an abstract predicate, either function return type or the argument types should contain that predicate
  - More complex way: in addition to above, also propagate the information about the arguments of the predicate:
    if it's in the function return type, unify the arguments and propagate that spec to the argument,
    otherwise, function must be univalent (~ contain _v = f x), then substitute f _v for _v in the original predicate and propagate that to the argument

When goal type contains abstract predicate, the only functions we should consider are the ones that produce the predicate or propagate the value, when a variable with this prdicate is around
- Try encoding of atomic flow with HO functions

Front-end:
	- Attach positions to AST nodes
