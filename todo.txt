- Split subtyping constraints with multiple measures?
- Vacuousness abduction with explicit match: doesn't care if the case conditions even play a role; both cases can be false (tests case: BST-DeleteMin)
- Type classes (for type variables and abstract datatypes)
- Symmetry reduction

- Examples to make work:
  - More complex uses of indexed list (e.g. reverse, Okazaki)
  - Jeevana's/Leon's desugaring
  - foldl
  - AVL trees without auxiliary functions  

- Mutual recursion
- Importing modules
- Prove measure postconditions
- Irrefutable type errors (like symbol not in scope)
- Check that the first constructor is the base case
- Multisets
- Named arguments for abstract predicates
- Intersection types (carry multiple environments and type constraint checkers), good example: allPos :: (List Int -> Bool) &&& (List Pos -> {Bool | _v}) &&& ({List Nonpos | len _v > 0} -> {Bool | !_v})