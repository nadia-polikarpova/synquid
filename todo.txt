- In matches: instantiate all constructor schemas together with the same free variables
- Replace measures/predicates with arbitrary logic functions, give measures definitions, turn abstract datatypes into bound type variables, allow equality on them, but not other datatypes
- Disallow sets in formula programs

- Type classes (for type variables and abstract datatypes)
- Default cond qualifiers
- More principled type substitution and qualifier discovery, translate type variables and datatypes into uninterpreted types

- Irrefutable type errors (like symbol not in scope)
- Collect stats: how big is env embedding? how many candidates? how many active/inactive constraints?
- Should let-defs and known conditionals have abstracted types?
- Memoization: remove subsumed components?
- Prove measure postconditions
- BUG: polymorphic qualifier extraction
- Check that the first constructor is the base case
- When a measure is not mentioned in the goal spec, remove it from the components?

Security:
- Make use of abstract predicates:
  - Simple way: when the goal type contains an abstract predicate, either function return type or the argument types should contain that predicate
  - More complex way: in addition to above, also propagate the information about the arguments of the predicate:
    if it's in the function return type, unify the arguments and propagate that spec to the argument,
    otherwise, function must be univalent (~ contain _v = f x), then substitute f _v for _v in the original predicate and propagate that to the argument

When goal type contains abstract predicate, the only functions we should consider are the ones that produce the predicate or propagate the value, when a variable with this prdicate is around
- Try encoding of atomic flow with HO functions

Front-end:
	- Make resolver multi-pass so that order of declarations doesn't matter
	- Check if wf-metric is defined
	- Attach positions to AST nodes?
