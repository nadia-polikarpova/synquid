- More principled type substitution and qualifier discovery, translate type variables and datatypes into uninterpreted types
  - Missing match qualifiers (AddressBook)?
  - Use unifySorts for qualifier substitution instead of complies
  - Do we even need qualifiers from component types?
- Inline functions
- Named arguments for abstract predicates
- Collapse lambda-expansions in aux goals
- Parametrization by non-boolean predicates
- Mutual recursion
- Type classes (for type variables and abstract datatypes)
- Default cond qualifiers
- Solve the keys measure mystery in BST-delete
- Remove subsumed components (0 + x -> x, x + y -> y + x)

- Irrefutable type errors (like symbol not in scope)
- Collect stats: how big is env embedding? how many candidates? how many active/inactive constraints?
- Should let-defs and known conditionals have abstracted types?
- Prove measure postconditions
- BUG: polymorphic qualifier extraction
- Check that the first constructor is the base case
- When a measure is not mentioned in the goal spec, remove it from the components?

Security:
- Make use of abstract predicates:
  - Simple way: when the goal type contains an abstract predicate, either function return type or the argument types should contain that predicate
  - More complex way: in addition to above, also propagate the information about the arguments of the predicate:
    if it's in the function return type, unify the arguments and propagate that spec to the argument,
    otherwise, function must be univalent (~ contain _v = f x), then substitute f _v for _v in the original predicate and propagate that to the argument

When goal type contains abstract predicate, the only functions we should consider are the ones that produce the predicate or propagate the value, when a variable with this prdicate is around
- Try encoding of atomic flow with HO functions

Front-end:
	- Attach positions to AST nodes
