- Should we abduce conditions from argument holes? Should if ?? even be allowed?
- Better error messages
- Resolve formulas with free type variables in conditionals: get rid of formula programs
- Should let-defs and known conditionals have abstracted types?
- More principled type substitution
- In matches: instantiate all constructor schemas together with the same free variables

- Type classes (to help instantiate qualifiers)	

- Do something with datatype equality: does it make everything slower? Eq?

- Forget unknowns between branches
- Try to reduce the size of environment embedding? 
- Memoization: remove subsumed components?
- Prove measure postconditions
- BUG: polymorphic qualifier extraction
- Check that the first constructor is the base case
- When a measure is not mentioned in the goal spec, remove it from the components?
- If we are looking for a datatype with a constraint on a measure that, for a certain constructor, only depends on some arguments, we can test that subtyping before finding all the other arguments

Security:
- How to make use of the type of strcatFlow to figure out that the label to pass into fwrite should contain J (F fin) (F fout)
- When goal type contains abstract predicate, the only functions we should consider are the ones that produce the predicate or propagate the value, when a variable with this prdicate is around
- Try encoding of atomic flow with HO functions

Front-end:
  - Change parser to indentation-based
	- Make resolver multi-pass so that order of declarations doesn't matter
	- Check if wf-metric is defined
	- Attach positions to AST nodes?
